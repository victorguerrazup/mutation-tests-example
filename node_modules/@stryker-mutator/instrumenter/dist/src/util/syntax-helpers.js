"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deepCloneNode = exports.locationOverlaps = exports.locationIncluded = exports.isImportDeclaration = exports.isTypeNode = exports.mutationCoverageSequenceExpression = exports.offsetLocations = exports.eqNode = exports.mutantTestExpression = exports.instrumentationBabelHeader = exports.ID = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@stryker-mutator/api/core");
Object.defineProperty(exports, "ID", { enumerable: true, get: function () { return core_1.INSTRUMENTER_CONSTANTS; } });
const core_2 = require("@babel/core");
const traverse_1 = (0, tslib_1.__importDefault)(require("@babel/traverse"));
const parser_1 = require("@babel/parser");
const util_1 = require("@stryker-mutator/util");
const STRYKER_NAMESPACE_HELPER = 'stryNS_9fa48';
const COVER_MUTANT_HELPER = 'stryCov_9fa48';
const IS_MUTANT_ACTIVE_HELPER = 'stryMutAct_9fa48';
/**
 * Returns syntax for the header if JS/TS files
 */
exports.instrumentationBabelHeader = (0, util_1.deepFreeze)((0, parser_1.parse)(`function ${STRYKER_NAMESPACE_HELPER}(){
  var g = new Function("return this")();
  var ns = g.${core_1.INSTRUMENTER_CONSTANTS.NAMESPACE} || (g.${core_1.INSTRUMENTER_CONSTANTS.NAMESPACE} = {});
  if (ns.${core_1.INSTRUMENTER_CONSTANTS.ACTIVE_MUTANT} === undefined && g.process && g.process.env && g.process.env.${core_1.INSTRUMENTER_CONSTANTS.ACTIVE_MUTANT_ENV_VARIABLE}) {
    ns.${core_1.INSTRUMENTER_CONSTANTS.ACTIVE_MUTANT} = g.process.env.${core_1.INSTRUMENTER_CONSTANTS.ACTIVE_MUTANT_ENV_VARIABLE};
  }
  function retrieveNS(){
    return ns;
  }
  ${STRYKER_NAMESPACE_HELPER} = retrieveNS;
  return retrieveNS();
}
${STRYKER_NAMESPACE_HELPER}();

function ${COVER_MUTANT_HELPER}() {
  var ns = ${STRYKER_NAMESPACE_HELPER}();
  var cov = ns.${core_1.INSTRUMENTER_CONSTANTS.MUTATION_COVERAGE_OBJECT} || (ns.${core_1.INSTRUMENTER_CONSTANTS.MUTATION_COVERAGE_OBJECT} = { static: {}, perTest: {} });
  function cover() {
    var c = cov.static;
    if (ns.${core_1.INSTRUMENTER_CONSTANTS.CURRENT_TEST_ID}) {
      c = cov.perTest[ns.${core_1.INSTRUMENTER_CONSTANTS.CURRENT_TEST_ID}] = cov.perTest[ns.${core_1.INSTRUMENTER_CONSTANTS.CURRENT_TEST_ID}] || {};
    }
    var a = arguments;
    for(var i=0; i < a.length; i++){
      c[a[i]] = (c[a[i]] || 0) + 1;
    }
  }
  ${COVER_MUTANT_HELPER} = cover;
  cover.apply(null, arguments);
}
function ${IS_MUTANT_ACTIVE_HELPER}(id) {
  var ns = ${STRYKER_NAMESPACE_HELPER}();
  function isActive(id) {
    if (ns.${core_1.INSTRUMENTER_CONSTANTS.ACTIVE_MUTANT} === id) {
      if (ns.${core_1.INSTRUMENTER_CONSTANTS.HIT_COUNT} !== void 0 && ++ns.${core_1.INSTRUMENTER_CONSTANTS.HIT_COUNT} > ns.${core_1.INSTRUMENTER_CONSTANTS.HIT_LIMIT}) {
        throw new Error('Stryker: Hit count limit reached (' + ns.${core_1.INSTRUMENTER_CONSTANTS.HIT_COUNT} + ')');
      }
      return true;
    }
    return false;
  }
  ${IS_MUTANT_ACTIVE_HELPER} = isActive;
  return isActive(id);
}`).program.body); // cast here, otherwise the thing gets unwieldy to handle
/**
 * returns syntax for `global.activeMutant === $mutantId`
 * @param mutantId The id of the mutant to switch
 */
function mutantTestExpression(mutantId) {
    return core_2.types.callExpression(core_2.types.identifier(IS_MUTANT_ACTIVE_HELPER), [core_2.types.stringLiteral(mutantId)]);
}
exports.mutantTestExpression = mutantTestExpression;
function eqLocation(a, b) {
    function eqPosition(start, end) {
        return start.column === end.column && start.line === end.line;
    }
    return eqPosition(a.start, b.start) && eqPosition(a.end, b.end);
}
function eqNode(a, b) {
    return a.type === b.type && !!a.loc && !!b.loc && eqLocation(a.loc, b.loc);
}
exports.eqNode = eqNode;
function offsetLocations(file, { position, line, column }) {
    const offsetNode = (node) => {
        node.start += position;
        node.end += position;
        //  we need to subtract 1, as lines always start at 1
        node.loc.start.line += line - 1;
        node.loc.end.line += line - 1;
        if (node.loc.start.line === line) {
            node.loc.start.column += column;
        }
        if (node.loc.end.line === line) {
            node.loc.end.column += column;
        }
    };
    (0, traverse_1.default)(file, {
        enter(path) {
            offsetNode(path.node);
        },
    });
    // Don't forget the file itself!
    file.start += position;
    file.end += position;
}
exports.offsetLocations = offsetLocations;
/**
 * Returns a sequence of mutation coverage counters with an optional last expression.
 *
 * @example (global.__coverMutant__(0, 1), 40 + 2)
 * @param mutants The mutants for which covering syntax needs to be generated
 * @param targetExpression The original expression
 */
function mutationCoverageSequenceExpression(mutants, targetExpression) {
    const mutantIds = [...mutants].map((mutant) => core_2.types.stringLiteral(mutant.id));
    const sequence = [core_2.types.callExpression(core_2.types.identifier(COVER_MUTANT_HELPER), mutantIds)];
    if (targetExpression) {
        sequence.push(targetExpression);
    }
    return core_2.types.sequenceExpression(sequence);
}
exports.mutationCoverageSequenceExpression = mutationCoverageSequenceExpression;
function isTypeNode(path) {
    return (path.isTypeAnnotation() ||
        flowTypeAnnotationNodeTypes.includes(path.node.type) ||
        tsTypeAnnotationNodeTypes.includes(path.node.type) ||
        isDeclareVariableStatement(path) ||
        isDeclareModule(path));
}
exports.isTypeNode = isTypeNode;
/**
 * Determines whether or not it is a declare variable statement node.
 * @example
 * declare const foo: 'foo';
 */
function isDeclareVariableStatement(path) {
    return path.isVariableDeclaration() && path.node.declare === true;
}
/**
 * Determines whether or not a node is a string literal that is the name of a module.
 * @example
 * declare module "express" {};
 */
function isDeclareModule(path) {
    var _a;
    return path.isTSModuleDeclaration() && ((_a = path.node.declare) !== null && _a !== void 0 ? _a : false);
}
const tsTypeAnnotationNodeTypes = Object.freeze([
    'TSAsExpression',
    'TSInterfaceDeclaration',
    'TSTypeAnnotation',
    'TSTypeAliasDeclaration',
    'TSEnumDeclaration',
    'TSDeclareFunction',
    'TSTypeParameterInstantiation',
    'TSTypeParameterDeclaration',
]);
const flowTypeAnnotationNodeTypes = Object.freeze([
    'DeclareClass',
    'DeclareFunction',
    'DeclareInterface',
    'DeclareModule',
    'DeclareModuleExports',
    'DeclareTypeAlias',
    'DeclareOpaqueType',
    'DeclareVariable',
    'DeclareExportDeclaration',
    'DeclareExportAllDeclaration',
    'InterfaceDeclaration',
    'OpaqueType',
    'TypeAlias',
    'InterfaceDeclaration',
]);
function isImportDeclaration(path) {
    return core_2.types.isTSImportEqualsDeclaration(path.node) || path.isImportDeclaration();
}
exports.isImportDeclaration = isImportDeclaration;
/**
 * Determines if a location (needle) is included in an other location (haystack)
 * @param haystack The range to look in
 * @param needle the range to search for
 */
function locationIncluded(haystack, needle) {
    const startIncluded = haystack.start.line < needle.start.line || (haystack.start.line === needle.start.line && haystack.start.column <= needle.start.column);
    const endIncluded = haystack.end.line > needle.end.line || (haystack.end.line === needle.end.line && haystack.end.column >= needle.end.column);
    return startIncluded && endIncluded;
}
exports.locationIncluded = locationIncluded;
/**
 * Determines if two locations overlap with each other
 */
function locationOverlaps(a, b) {
    const startIncluded = a.start.line < b.end.line || (a.start.line === b.end.line && a.start.column <= b.end.column);
    const endIncluded = a.end.line > b.start.line || (a.end.line === b.start.line && a.end.column >= b.start.column);
    return startIncluded && endIncluded;
}
exports.locationOverlaps = locationOverlaps;
/**
 * Helper for `types.cloneNode(node, deep: true, withoutLocations: false);`
 */
function deepCloneNode(node) {
    return core_2.types.cloneNode(node, /* deep */ true, /* withoutLocations */ false);
}
exports.deepCloneNode = deepCloneNode;
//# sourceMappingURL=syntax-helpers.js.map