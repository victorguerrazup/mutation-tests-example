"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseTsx = exports.parseTS = void 0;
const core_1 = require("@babel/core");
const syntax_1 = require("../syntax");
/**
 * See https://babeljs.io/docs/en/babel-preset-typescript
 * @param text The text to parse
 * @param fileName The name of the file
 */
async function parseTS(text, fileName) {
    return {
        originFileName: fileName,
        rawContent: text,
        format: syntax_1.AstFormat.TS,
        root: await parse(text, fileName, false),
    };
}
exports.parseTS = parseTS;
async function parseTsx(text, fileName) {
    return {
        root: await parse(text, fileName, true),
        format: syntax_1.AstFormat.Tsx,
        originFileName: fileName,
        rawContent: text,
    };
}
exports.parseTsx = parseTsx;
async function parse(text, fileName, isTSX) {
    const ast = await (0, core_1.parseAsync)(text, {
        filename: fileName,
        parserOpts: {
            ranges: true,
        },
        configFile: false,
        babelrc: false,
        presets: [[require.resolve('@babel/preset-typescript'), { isTSX, allExtensions: true }]],
        plugins: [
            require.resolve('@babel/plugin-proposal-class-properties'),
            require.resolve('@babel/plugin-proposal-private-methods'),
            [require.resolve('@babel/plugin-proposal-decorators'), { legacy: true }],
        ],
    });
    if (ast === null) {
        throw new Error(`Expected ${fileName} to contain a babel.types.file, but it yielded null`);
    }
    if (core_1.types.isProgram(ast)) {
        throw new Error(`Expected ${fileName} to contain a babel.types.file, but was a program`);
    }
    return ast;
}
//# sourceMappingURL=ts-parser.js.map