"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformBabel = void 0;
const core_1 = require("@babel/core");
/* eslint-disable @typescript-eslint/no-duplicate-imports */
// @ts-expect-error The babel types don't define "File" yet
const core_2 = require("@babel/core");
/* eslint-enable @typescript-eslint/no-duplicate-imports */
const mutators_1 = require("../mutators");
const syntax_helpers_1 = require("../util/syntax-helpers");
const mutant_placers_1 = require("../mutant-placers");
const directive_bookkeeper_1 = require("./directive-bookkeeper");
const transformBabel = ({ root, originFileName, rawContent, offset }, mutantCollector, { options }, mutators = mutators_1.allMutators, mutantPlacers = mutant_placers_1.allMutantPlacers) => {
    var _a, _b;
    // Wrap the AST in a `new File`, so `nodePath.buildCodeFrameError` works
    // https://github.com/babel/babel/issues/11889
    const file = new core_2.File({ filename: originFileName }, { code: rawContent, ast: root });
    // Range filters that are in scope for the current file
    const mutantRangesForCurrentFile = options.mutationRanges.filter((mutantRange) => mutantRange.fileName === originFileName);
    // Create a placementMap for the mutation switching bookkeeping
    const placementMap = new Map();
    // Create the bookkeeper responsible for the // Stryker ... directives
    const directiveBookkeeper = new directive_bookkeeper_1.DirectiveBookkeeper();
    // Now start the actual traversing of the AST
    //
    // On the way down:
    // * Treat the tree as immutable.
    // * Identify the nodes that can be used to place mutants on in the placement map.
    // * Generate the mutants on each node.
    //    * When a node generated mutants, do a short walk back up and register them in the placement map
    //    * Call the `applied` method using the placement node, that way the mutant will capture the AST with mutation all the way to the placement node
    //
    // On the way up:
    // * If this node has mutants in the placementMap, place them in the AST.
    //
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    (0, core_1.traverse)(file.ast, {
        enter(path) {
            directiveBookkeeper.processStrykerDirectives(path.node);
            if (shouldSkip(path)) {
                path.skip();
            }
            else {
                addToPlacementMapIfPossible(path);
                if (!mutantRangesForCurrentFile.length || mutantRangesForCurrentFile.some((range) => (0, syntax_helpers_1.locationIncluded)(range, path.node.loc))) {
                    const mutantsToPlace = collectMutants(path);
                    if (mutantsToPlace.length) {
                        registerInPlacementMap(path, mutantsToPlace);
                    }
                }
            }
        },
        exit(path) {
            placeMutantsIfNeeded(path);
        },
    });
    if (mutantCollector.hasPlacedMutants(originFileName)) {
        // Be sure to leave comments like `// @flow` in.
        let header = syntax_helpers_1.instrumentationBabelHeader;
        if (Array.isArray((_a = root.program.body[0]) === null || _a === void 0 ? void 0 : _a.leadingComments)) {
            header = [
                {
                    ...syntax_helpers_1.instrumentationBabelHeader[0],
                    leadingComments: (_b = root.program.body[0]) === null || _b === void 0 ? void 0 : _b.leadingComments,
                },
                ...syntax_helpers_1.instrumentationBabelHeader.slice(1),
            ];
        }
        root.program.body.unshift(...header);
    }
    /**
     *  If mutants were collected, be sure to register them in the placement map.
     */
    function registerInPlacementMap(path, mutantsToPlace) {
        const placementPath = path.find((ancestor) => placementMap.has(ancestor.node));
        if (placementPath) {
            const appliedMutants = placementMap.get(placementPath.node).appliedMutants;
            mutantsToPlace.forEach((mutant) => appliedMutants.set(mutant, mutant.applied(placementPath.node)));
        }
        else {
            throw new Error(`Mutants cannot be placed. This shouldn't happen! Unplaced mutants: ${JSON.stringify(mutantsToPlace, null, 2)}`);
        }
    }
    /**
     * If this node can be used to place mutants on, add to the placement map
     */
    function addToPlacementMapIfPossible(path) {
        const placer = mutantPlacers.find((p) => p.canPlace(path));
        if (placer) {
            placementMap.set(path.node, { appliedMutants: new Map(), placer });
        }
    }
    /**
     * Don't traverse import declarations, decorators and nodes that don't have overlap with the selected mutation ranges
     */
    function shouldSkip(path) {
        return ((0, syntax_helpers_1.isTypeNode)(path) ||
            (0, syntax_helpers_1.isImportDeclaration)(path) ||
            path.isDecorator() ||
            (mutantRangesForCurrentFile.length && mutantRangesForCurrentFile.every((range) => !(0, syntax_helpers_1.locationOverlaps)(range, path.node.loc))));
    }
    /**
     * Place mutants that are assigned to the current node path (on exit)
     */
    function placeMutantsIfNeeded(path) {
        const mutantsPlacement = placementMap.get(path.node);
        if (mutantsPlacement === null || mutantsPlacement === void 0 ? void 0 : mutantsPlacement.appliedMutants.size) {
            try {
                mutantsPlacement.placer.place(path, mutantsPlacement.appliedMutants);
                path.skip();
            }
            catch (error) {
                (0, mutant_placers_1.throwPlacementError)(error, path, mutantsPlacement.placer, [...mutantsPlacement.appliedMutants.keys()], originFileName);
            }
        }
    }
    /**
     * Collect the mutants for the current node and return the non-ignored.
     */
    function collectMutants(path) {
        return [...mutate(path)]
            .map((mutable) => mutantCollector.collect(originFileName, path.node, mutable, offset))
            .filter((mutant) => !mutant.ignoreReason);
    }
    /**
     * Generate mutants for the current node.
     */
    function* mutate(node) {
        var _a;
        for (const mutator of mutators) {
            for (const replacement of mutator.mutate(node)) {
                yield {
                    replacement,
                    mutatorName: mutator.name,
                    ignoreReason: (_a = directiveBookkeeper.findIgnoreReason(node.node.loc.start.line, mutator.name)) !== null && _a !== void 0 ? _a : formatIgnoreReason(mutator.name),
                };
            }
        }
        function formatIgnoreReason(mutatorName) {
            if (options.excludedMutations.includes(mutatorName)) {
                return `Ignored because of excluded mutation "${mutatorName}"`;
            }
            else {
                return undefined;
            }
        }
    }
};
exports.transformBabel = transformBabel;
//# sourceMappingURL=babel-transformer.js.map