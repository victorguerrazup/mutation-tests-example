"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.expressionMutantPlacer = void 0;
const core_1 = require("@babel/core");
const syntax_helpers_1 = require("../util/syntax-helpers");
/**
 * Will set the identifier of anonymous function expressions if is located in a variable declaration.
 * Will treat input as readonly. Returns undefined if not needed.
 * @example
 * const a = function() { }
 * becomes
 * const a = function a() {}
 */
function classOrFunctionExpressionNamedIfNeeded(path) {
    var _a;
    if ((path.isFunctionExpression() || path.isClassExpression()) && !path.node.id) {
        if (path.parentPath.isVariableDeclarator() && core_1.types.isIdentifier(path.parentPath.node.id)) {
            path.node.id = path.parentPath.node.id;
        }
        else if (path.parentPath.isObjectProperty() &&
            core_1.types.isIdentifier(path.parentPath.node.key) &&
            ((_a = path.getStatementParent()) === null || _a === void 0 ? void 0 : _a.isVariableDeclaration())) {
            path.node.id = path.parentPath.node.key;
        }
    }
    return;
}
/**
 * Will set the identifier of anonymous arrow function expressions if is located in a variable declaration.
 * Will treat input as readonly. Returns undefined if not needed.
 * @example
 * const a = () => { }
 * becomes
 * const a = (() => { const a = () => {}; return a; })()
 */
function arrowFunctionExpressionNamedIfNeeded(path) {
    if (path.isArrowFunctionExpression() && path.parentPath.isVariableDeclarator() && core_1.types.isIdentifier(path.parentPath.node.id)) {
        return core_1.types.callExpression(core_1.types.arrowFunctionExpression([], core_1.types.blockStatement([
            core_1.types.variableDeclaration('const', [core_1.types.variableDeclarator(path.parentPath.node.id, path.node)]),
            core_1.types.returnStatement(path.parentPath.node.id),
        ])), []);
    }
    return;
}
function nameIfAnonymous(path) {
    var _a, _b;
    return (_b = (_a = classOrFunctionExpressionNamedIfNeeded(path)) !== null && _a !== void 0 ? _a : arrowFunctionExpressionNamedIfNeeded(path)) !== null && _b !== void 0 ? _b : path.node;
}
function isMemberOrCallExpression(path) {
    return isCallExpression(path) || isMemberExpression(path);
}
function isMemberExpression(path) {
    return path.isMemberExpression() || path.isOptionalMemberExpression() || path.isTSNonNullExpression();
}
function isCallExpression(path) {
    return path.isCallExpression() || path.isOptionalCallExpression();
}
function isValidExpression(path) {
    const parent = path.parentPath;
    return !isObjectPropertyKey() && !isPartOfChain() && !parent.isTaggedTemplateExpression();
    /**
     * Determines if the expression is property of an object.
     * @example
     * const a = {
     *  'foo': 'bar' // 'foo' here is an object property
     * };
     */
    function isObjectPropertyKey() {
        return parent.isObjectProperty() && parent.node.key === path.node;
    }
    /**
     * Determines if the expression is part of a call/member chain.
     * @example
     * // bar is part of chain, foo is NOT part of the chain:
     * foo.bar.baz();
     * foo.bar?.baz()
     * foo.bar;
     * foo.bar();
     * foo?.bar();
     */
    function isPartOfChain() {
        return isMemberOrCallExpression(path) && (isMemberExpression(parent) || (isCallExpression(parent) && parent.node.callee === path.node));
    }
}
/**
 * Places the mutants with a conditional expression: `global.activeMutant === 1? mutatedCode : originalCode`;
 */
exports.expressionMutantPlacer = {
    name: 'expressionMutantPlacer',
    canPlace(path) {
        return path.isExpression() && isValidExpression(path);
    },
    place(path, appliedMutants) {
        // Make sure anonymous functions and classes keep their 'name' property
        let expression = nameIfAnonymous(path);
        // Add the mutation coverage expression
        expression = (0, syntax_helpers_1.mutationCoverageSequenceExpression)(appliedMutants.keys(), expression);
        // Now apply the mutants
        for (const [mutant, appliedMutant] of appliedMutants) {
            expression = core_1.types.conditionalExpression((0, syntax_helpers_1.mutantTestExpression)(mutant.id), appliedMutant, expression);
        }
        path.replaceWith(expression);
    },
};
//# sourceMappingURL=expression-mutant-placer.js.map