"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Mutant = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@babel/core");
const generator_1 = (0, tslib_1.__importDefault)(require("@babel/generator"));
const core_2 = require("@stryker-mutator/api/core");
const util_1 = require("./util");
class Mutant {
    constructor(id, fileName, original, specs, offset = { position: 0, line: 0 }) {
        this.id = id;
        this.fileName = fileName;
        this.original = original;
        this.offset = offset;
        this.replacement = specs.replacement;
        this.mutatorName = specs.mutatorName;
        this.ignoreReason = specs.ignoreReason;
        this.replacementCode = (0, generator_1.default)(this.replacement).code;
    }
    toApiMutant() {
        return {
            fileName: this.fileName,
            id: this.id,
            location: toApiLocation(this.original.loc, this.offset.line),
            mutatorName: this.mutatorName,
            replacement: this.replacementCode,
            statusReason: this.ignoreReason,
            status: this.ignoreReason ? core_2.MutantStatus.Ignored : undefined,
        };
    }
    /**
     * Applies the mutant in (a copy of) the AST, without changing provided AST.
     * Can the tree itself (in which case the replacement is returned),
     * or can be nested in the given tree.
     * @param originalTree The original node, which will be treated as readonly
     */
    applied(originalTree) {
        if (originalTree === this.original) {
            return this.replacement;
        }
        else {
            const mutatedAst = (0, util_1.deepCloneNode)(originalTree);
            let applied = false;
            const { original, replacement } = this;
            (0, core_1.traverse)(mutatedAst, {
                noScope: true,
                enter(path) {
                    if ((0, util_1.eqNode)(path.node, original)) {
                        path.replaceWith(replacement);
                        path.stop();
                        applied = true;
                    }
                },
            });
            if (!applied) {
                throw new Error(`Could not apply mutant ${JSON.stringify(this.replacement)}.`);
            }
            return mutatedAst;
        }
    }
}
exports.Mutant = Mutant;
function toApiLocation(source, lineOffset) {
    return {
        start: toPosition(source.start, lineOffset),
        end: toPosition(source.end, lineOffset),
    };
}
function toPosition(source, lineOffset) {
    return {
        column: source.column,
        line: source.line + lineOffset - 1, // Stryker works 0-based internally
    };
}
//# sourceMappingURL=mutant.js.map