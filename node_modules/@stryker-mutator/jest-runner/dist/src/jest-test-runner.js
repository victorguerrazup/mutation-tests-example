"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JestTestRunner = exports.jestTestRunnerFactory = exports.createJestTestRunnerFactory = void 0;
const tslib_1 = require("tslib");
const path_1 = (0, tslib_1.__importDefault)(require("path"));
const core_1 = require("@stryker-mutator/api/core");
const plugin_1 = require("@stryker-mutator/api/plugin");
const test_runner_1 = require("@stryker-mutator/api/test-runner");
const util_1 = require("@stryker-mutator/util");
const jest_test_adapters_1 = require("./jest-test-adapters");
const jest_plugins_1 = require("./jest-plugins");
const pluginTokens = (0, tslib_1.__importStar)(require("./plugin-tokens"));
const config_loaders_1 = require("./config-loaders");
const jest_override_options_1 = require("./jest-override-options");
const utils_1 = require("./utils");
const messaging_1 = require("./messaging");
function createJestTestRunnerFactory(namespace = core_1.INSTRUMENTER_CONSTANTS.NAMESPACE) {
    jestTestRunnerFactory.inject = (0, plugin_1.tokens)(plugin_1.commonTokens.injector);
    function jestTestRunnerFactory(injector) {
        return injector
            .provideValue(pluginTokens.processEnv, process.env)
            .provideValue(pluginTokens.jestVersion, utils_1.jestWrapper.getVersion())
            .provideFactory(pluginTokens.jestTestAdapter, jest_test_adapters_1.jestTestAdapterFactory)
            .provideFactory(pluginTokens.configLoader, config_loaders_1.configLoaderFactory)
            .provideValue(pluginTokens.globalNamespace, namespace)
            .injectClass(JestTestRunner);
    }
    return jestTestRunnerFactory;
}
exports.createJestTestRunnerFactory = createJestTestRunnerFactory;
exports.jestTestRunnerFactory = createJestTestRunnerFactory();
class JestTestRunner {
    constructor(log, options, processEnvRef, jestTestAdapter, configLoader, globalNamespace) {
        this.log = log;
        this.processEnvRef = processEnvRef;
        this.jestTestAdapter = jestTestAdapter;
        this.globalNamespace = globalNamespace;
        this.jestOptions = options.jest;
        // Get jest configuration from stryker options and assign it to jestConfig
        const configFromFile = configLoader.loadConfig();
        this.jestConfig = this.mergeConfigSettings(configFromFile, this.jestOptions || {});
        // Get enableFindRelatedTests from stryker jest options or default to true
        this.enableFindRelatedTests = this.jestOptions.enableFindRelatedTests;
        if (this.enableFindRelatedTests) {
            this.log.debug('Running jest with --findRelatedTests flag. Set jest.enableFindRelatedTests to false to run all tests on every mutant.');
        }
        else {
            this.log.debug('Running jest without --findRelatedTests flag. Set jest.enableFindRelatedTests to true to run only relevant tests on every mutant.');
        }
    }
    async dryRun({ coverageAnalysis, disableBail, files, }) {
        messaging_1.state.coverageAnalysis = coverageAnalysis;
        const mutantCoverage = { perTest: {}, static: {} };
        const fileNamesWithMutantCoverage = [];
        if (coverageAnalysis !== 'off') {
            messaging_1.state.setMutantCoverageHandler((fileName, report) => {
                (0, utils_1.mergeMutantCoverage)(mutantCoverage, report);
                fileNamesWithMutantCoverage.push(fileName);
            });
        }
        const fileNamesUnderTest = this.enableFindRelatedTests ? files : undefined;
        try {
            const { dryRunResult, jestResult } = await this.run({
                fileNamesUnderTest,
                jestConfig: this.configForDryRun(fileNamesUnderTest, coverageAnalysis),
                testLocationInResults: true,
            });
            if (dryRunResult.status === test_runner_1.DryRunStatus.Complete && coverageAnalysis !== 'off') {
                const errorMessage = (0, utils_1.verifyAllTestFilesHaveCoverage)(jestResult, fileNamesWithMutantCoverage);
                if (errorMessage) {
                    return {
                        status: test_runner_1.DryRunStatus.Error,
                        errorMessage,
                    };
                }
                else {
                    dryRunResult.mutantCoverage = mutantCoverage;
                }
            }
            return dryRunResult;
        }
        finally {
            messaging_1.state.resetMutantCoverageHandler();
        }
    }
    async mutantRun({ activeMutant, sandboxFileName, testFilter, disableBail }) {
        const fileNameUnderTest = this.enableFindRelatedTests ? sandboxFileName : undefined;
        messaging_1.state.coverageAnalysis = 'off';
        let testNamePattern;
        if (testFilter) {
            testNamePattern = testFilter.map((testId) => `(${(0, util_1.escapeRegExp)(testId)})`).join('|');
        }
        process.env[core_1.INSTRUMENTER_CONSTANTS.ACTIVE_MUTANT_ENV_VARIABLE] = activeMutant.id.toString();
        try {
            const { dryRunResult } = await this.run({
                fileNamesUnderTest: fileNameUnderTest ? [fileNameUnderTest] : undefined,
                jestConfig: this.configForMutantRun(fileNameUnderTest),
                testNamePattern,
            });
            return (0, test_runner_1.toMutantRunResult)(dryRunResult, disableBail);
        }
        finally {
            delete process.env[core_1.INSTRUMENTER_CONSTANTS.ACTIVE_MUTANT_ENV_VARIABLE];
        }
    }
    configForDryRun(fileNamesUnderTest, coverageAnalysis) {
        return (0, jest_plugins_1.withCoverageAnalysis)(this.configWithRoots(fileNamesUnderTest), coverageAnalysis);
    }
    configForMutantRun(fileNameUnderTest) {
        return this.configWithRoots(fileNameUnderTest ? [fileNameUnderTest] : undefined);
    }
    configWithRoots(fileNamesUnderTest) {
        let config;
        if (fileNamesUnderTest && this.jestConfig.roots) {
            // Make sure the file under test lives inside one of the roots
            config = {
                ...this.jestConfig,
                roots: [...this.jestConfig.roots, ...new Set(fileNamesUnderTest.map((file) => path_1.default.dirname(file)))],
            };
        }
        else {
            config = this.jestConfig;
        }
        return config;
    }
    async run(settings) {
        this.setEnv();
        if (this.log.isTraceEnabled()) {
            this.log.trace('Invoking Jest with config %s', JSON.stringify(settings));
        }
        const { results } = await this.jestTestAdapter.run(settings);
        return { dryRunResult: this.collectRunResult(results), jestResult: results };
    }
    collectRunResult(results) {
        if (results.numRuntimeErrorTestSuites) {
            const errorMessage = results.testResults
                .map((testSuite) => this.collectSerializableErrorText(testSuite.testExecError))
                .filter(util_1.notEmpty)
                .join(', ');
            return {
                status: test_runner_1.DryRunStatus.Error,
                errorMessage,
            };
        }
        else {
            return {
                status: test_runner_1.DryRunStatus.Complete,
                tests: this.processTestResults(results.testResults),
            };
        }
    }
    collectSerializableErrorText(error) {
        return error && `${error.code && `${error.code} `}${error.message} ${error.stack}`;
    }
    setEnv() {
        // Jest CLI will set process.env.NODE_ENV to 'test' when it's null, do the same here
        // https://github.com/facebook/jest/blob/master/packages/jest-cli/bin/jest.js#L12-L14
        if (!this.processEnvRef.NODE_ENV) {
            this.processEnvRef.NODE_ENV = 'test';
        }
        // Force colors off: https://github.com/chalk/supports-color#info
        process.env.FORCE_COLOR = '0';
        if (this.jestOptions.projectType === 'create-react-app') {
            try {
                (0, util_1.requireResolve)('react-scripts/config/env.js');
            }
            catch (err) {
                this.log.warn('Unable to load environment variables using "react-scripts/config/env.js". The environment variables might differ from expected. Please open an issue if you think this is a bug: https://github.com/stryker-mutator/stryker-js/issues/new/choose.');
                this.log.debug('Inner error', err);
            }
        }
    }
    processTestResults(suiteResults) {
        var _a;
        const testResults = [];
        for (const suiteResult of suiteResults) {
            for (const testResult of suiteResult.testResults) {
                const result = {
                    id: testResult.fullName,
                    name: testResult.fullName,
                    timeSpentMs: (_a = testResult.duration) !== null && _a !== void 0 ? _a : 0,
                    fileName: suiteResult.testFilePath,
                    startPosition: testResult.location
                        ? {
                            // Stryker works 0-based internally, jest works 1-based: https://jestjs.io/docs/cli#--testlocationinresults
                            line: testResult.location.line - 1,
                            column: testResult.location.column,
                        }
                        : undefined,
                };
                switch (testResult.status) {
                    case 'passed':
                        testResults.push({
                            status: test_runner_1.TestStatus.Success,
                            ...result,
                        });
                        break;
                    case 'failed':
                        testResults.push({
                            status: test_runner_1.TestStatus.Failed,
                            failureMessage: testResult.failureMessages.join(', '),
                            ...result,
                        });
                        break;
                    default:
                        testResults.push({
                            status: test_runner_1.TestStatus.Skipped,
                            ...result,
                        });
                        break;
                }
            }
        }
        return testResults;
    }
    mergeConfigSettings(configFromFile, options) {
        var _a;
        const config = ((_a = options.config) !== null && _a !== void 0 ? _a : {});
        const stringify = (obj) => JSON.stringify(obj, null, 2);
        this.log.debug(`Merging file-based config ${stringify(configFromFile)}
      with custom config ${stringify(config)}
      and default (internal) stryker config ${stringify(jest_override_options_1.JEST_OVERRIDE_OPTIONS)}`);
        const mergedConfig = {
            ...configFromFile,
            ...config,
            ...jest_override_options_1.JEST_OVERRIDE_OPTIONS,
        };
        mergedConfig.globals = {
            ...mergedConfig.globals,
            __strykerGlobalNamespace__: this.globalNamespace,
        };
        return mergedConfig;
    }
}
exports.JestTestRunner = JestTestRunner;
JestTestRunner.inject = (0, plugin_1.tokens)(plugin_1.commonTokens.logger, plugin_1.commonTokens.options, pluginTokens.processEnv, pluginTokens.jestTestAdapter, pluginTokens.configLoader, pluginTokens.globalNamespace);
//# sourceMappingURL=jest-test-runner.js.map