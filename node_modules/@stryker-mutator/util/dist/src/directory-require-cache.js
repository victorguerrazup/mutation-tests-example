"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DirectoryRequireCache = void 0;
const tslib_1 = require("tslib");
const path_1 = (0, tslib_1.__importDefault)(require("path"));
const not_empty_1 = require("./not-empty");
const platform_1 = require("./platform");
/**
 * A helper class that can be used by test runners.
 * The first time you call `record`, it will fill the internal registry with the files required in the current working directory (excluding node_modules)
 * Then each time you call `clear` it will clear those files from the require cache
 *
 * It will also delete the `module.children` property of the root module.
 * @see https://github.com/stryker-mutator/stryker-js/issues/2461
 */
class DirectoryRequireCache {
    /**
     * Records the files required in the current working directory (excluding node_modules)
     * Only does so the first time, any subsequent calls will be ignored
     */
    record() {
        if (!this.cache) {
            const cache = (this.cache = new Set());
            const cwd = process.cwd();
            const startsWithCaseInsensitive = (filename, prefix) => filename.toLowerCase().startsWith(prefix.toLowerCase());
            const startsWithCaseSensitive = (filename, prefix) => filename.startsWith(prefix);
            const startsWith = (0, platform_1.caseSensitiveFs)() ? startsWithCaseSensitive : startsWithCaseInsensitive;
            Object.keys(require.cache)
                .filter((fileName) => startsWith(fileName, `${cwd}${path_1.default.sep}`) && !startsWith(fileName, path_1.default.join(cwd, 'node_modules')))
                .forEach((file) => cache.add(file));
            this.parents = new Set(Array.from(cache)
                // `module.parent` is deprecated, but seems to work fine, might never be removed.
                // See https://nodejs.org/api/modules.html#modules_module_parent
                .map((fileName) => { var _a, _b; return (_b = (_a = require.cache[fileName]) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.filename; })
                .filter(not_empty_1.notEmpty)
                // Filter out any parents that are in the current cache, since they will be removed anyway
                .filter((parentFileName) => !cache.has(parentFileName)));
        }
    }
    clear() {
        if (this.cache && this.parents) {
            const cache = this.cache;
            this.parents.forEach((parent) => {
                const parentModule = require.cache[parent];
                if (parentModule) {
                    parentModule.children = parentModule.children.filter((childModule) => !cache.has(childModule.id));
                }
            });
            cache.forEach((fileName) => delete require.cache[fileName]);
        }
    }
}
exports.DirectoryRequireCache = DirectoryRequireCache;
//# sourceMappingURL=directory-require-cache.js.map