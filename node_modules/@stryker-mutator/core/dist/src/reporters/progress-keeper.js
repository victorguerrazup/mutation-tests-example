"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProgressKeeper = void 0;
const core_1 = require("@stryker-mutator/api/core");
const timer_1 = require("../utils/timer");
function mutantHasCoverage(mutant) {
    var _a;
    return !!mutant.static || !!((_a = mutant.coveredBy) === null || _a === void 0 ? void 0 : _a.length);
}
class ProgressKeeper {
    constructor() {
        this.progress = {
            survived: 0,
            timedOut: 0,
            tested: 0,
            total: 0,
        };
    }
    onAllMutantsMatchedWithTests(mutants) {
        this.timer = new timer_1.Timer();
        this.progress.total = mutants.filter(mutantHasCoverage).length;
    }
    onMutantTested(result) {
        if (mutantHasCoverage(result)) {
            this.progress.tested++;
        }
        if (result.status === core_1.MutantStatus.Survived) {
            this.progress.survived++;
        }
        if (result.status === core_1.MutantStatus.Timeout) {
            this.progress.timedOut++;
        }
    }
    getElapsedTime() {
        return this.formatTime(this.timer.elapsedSeconds());
    }
    getEtc() {
        const totalSecondsLeft = Math.floor((this.timer.elapsedSeconds() / this.progress.tested) * (this.progress.total - this.progress.tested));
        if (isFinite(totalSecondsLeft) && totalSecondsLeft > 0) {
            return this.formatTime(totalSecondsLeft);
        }
        else {
            return 'n/a';
        }
    }
    formatTime(timeInSeconds) {
        const hours = Math.floor(timeInSeconds / 3600);
        const minutes = Math.floor((timeInSeconds % 3600) / 60);
        return hours > 0 // conditional time formatting
            ? `~${hours}h ${minutes}m`
            : minutes > 0
                ? `~${minutes}m`
                : '<1m';
    }
}
exports.ProgressKeeper = ProgressKeeper;
//# sourceMappingURL=progress-keeper.js.map