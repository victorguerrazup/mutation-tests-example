"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findNodeModulesList = exports.symlinkJunction = exports.moveDirectoryRecursiveSync = exports.importModule = exports.cleanFolder = exports.deleteDir = exports.glob = exports.mkdirp = exports.MAX_CONCURRENT_FILE_IO = void 0;
const tslib_1 = require("tslib");
const path_1 = (0, tslib_1.__importDefault)(require("path"));
const fs_1 = (0, tslib_1.__importDefault)(require("fs"));
const util_1 = require("util");
const glob_1 = (0, tslib_1.__importDefault)(require("glob"));
const mkdirp_1 = (0, tslib_1.__importDefault)(require("mkdirp"));
const rimraf_1 = (0, tslib_1.__importDefault)(require("rimraf"));
exports.MAX_CONCURRENT_FILE_IO = 256;
exports.mkdirp = mkdirp_1.default;
function glob(expression) {
    return new Promise((resolve, reject) => {
        (0, glob_1.default)(expression, { nodir: true }, (error, matches) => {
            error ? reject(error) : resolve(matches);
        });
    });
}
exports.glob = glob;
exports.deleteDir = (0, util_1.promisify)(rimraf_1.default);
async function cleanFolder(folderName) {
    try {
        await fs_1.default.promises.lstat(folderName);
        await (0, exports.deleteDir)(folderName);
        return (0, exports.mkdirp)(folderName);
    }
    catch (e) {
        return (0, exports.mkdirp)(folderName);
    }
}
exports.cleanFolder = cleanFolder;
/**
 * Wrapper around the 'require' function (for testability)
 */
function importModule(moduleName) {
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    return require(moduleName);
}
exports.importModule = importModule;
/**
 * Recursively walks the from directory and copy the content to the target directory synchronously
 * @param from The source directory to move from
 * @param to The target directory to move to
 */
function moveDirectoryRecursiveSync(from, to) {
    if (!fs_1.default.existsSync(from)) {
        return;
    }
    if (!fs_1.default.existsSync(to)) {
        fs_1.default.mkdirSync(to);
    }
    const files = fs_1.default.readdirSync(from);
    for (const file of files) {
        const fromFileName = path_1.default.join(from, file);
        const toFileName = path_1.default.join(to, file);
        const stats = fs_1.default.lstatSync(fromFileName);
        if (stats.isFile()) {
            fs_1.default.renameSync(fromFileName, toFileName);
        }
        else {
            moveDirectoryRecursiveSync(fromFileName, toFileName);
        }
    }
    fs_1.default.rmdirSync(from);
}
exports.moveDirectoryRecursiveSync = moveDirectoryRecursiveSync;
/**
 * Creates a symlink at `from` that points to `to`
 * @param to The thing you want to point to
 * @param from The thing you want to point from
 */
async function symlinkJunction(to, from) {
    await fs_1.default.promises.mkdir(path_1.default.dirname(from), { recursive: true });
    return fs_1.default.promises.symlink(to, from, 'junction');
}
exports.symlinkJunction = symlinkJunction;
/**
 * Looks for the node_modules folder from basePath up to root.
 * returns the first occurrence of the node_modules, or null of none could be found.
 * @param basePath starting point
 */
async function findNodeModulesList(basePath, tempDirName) {
    var _a;
    const nodeModulesList = [];
    const dirBfsQueue = (_a = ['.']) !== null && _a !== void 0 ? _a : [];
    let dir;
    while ((dir = dirBfsQueue.pop())) {
        if (path_1.default.basename(dir) === tempDirName) {
            continue;
        }
        if (path_1.default.basename(dir) === 'node_modules') {
            nodeModulesList.push(dir);
            continue;
        }
        const parentDir = dir;
        const filesWithType = await fs_1.default.promises.readdir(path_1.default.join(basePath, dir), { withFileTypes: true });
        const dirs = filesWithType.filter((file) => file.isDirectory()).map((childDir) => path_1.default.join(parentDir, childDir.name));
        dirBfsQueue.push(...dirs);
    }
    return nodeModulesList;
}
exports.findNodeModulesList = findNodeModulesList;
//# sourceMappingURL=file-utils.js.map