"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.markOptions = void 0;
const typed_inject_1 = require("typed-inject");
const plugin_1 = require("@stryker-mutator/api/plugin");
const util_1 = require("@stryker-mutator/util");
const di_1 = require("../di");
const object_utils_1 = require("../utils/object-utils");
markOptions.inject = (0, typed_inject_1.tokens)(plugin_1.commonTokens.options, di_1.coreTokens.validationSchema, plugin_1.commonTokens.logger);
/**
 * Performs additional validation on the Stryker options to mark unusual behavior with a warning.
 * Namely when a value isn't serializable or when unknown options are passed in.
 */
function markOptions(options, schema, log) {
    markUnknownOptions(options, schema, log);
    markUnserializableOptions(options, log);
    return options;
}
exports.markOptions = markOptions;
function markUnknownOptions(options, schema, log) {
    const OPTIONS_ADDED_BY_STRYKER = ['set', 'configFile', '$schema'];
    if ((0, object_utils_1.isWarningEnabled)('unknownOptions', options.warnings)) {
        const schemaKeys = Object.keys(schema.properties);
        const unknownPropertyNames = Object.keys(options)
            .filter((key) => !key.endsWith('_comment'))
            .filter((key) => !OPTIONS_ADDED_BY_STRYKER.includes(key))
            .filter((key) => !schemaKeys.includes(key));
        if (unknownPropertyNames.length) {
            unknownPropertyNames.forEach((unknownPropertyName) => {
                log.warn(`Unknown stryker config option "${unknownPropertyName}".`);
            });
            const p = util_1.PropertyPathBuilder.create().prop('warnings').prop('unknownOptions').build();
            log.warn(`Possible causes:
   * Is it a typo on your end?
   * Did you only write this property as a comment? If so, please postfix it with "_comment".
   * You might be missing a plugin that is supposed to use it. Stryker loaded plugins from: ${JSON.stringify(options.plugins)}
   * The plugin that is using it did not contribute explicit validation. 
   (disable "${p}" to ignore this warning)`);
        }
    }
}
function markUnserializableOptions(options, log) {
    if ((0, object_utils_1.isWarningEnabled)('unserializableOptions', options.warnings)) {
        const unserializables = (0, util_1.findUnserializables)(options);
        if (unserializables) {
            unserializables.forEach(({ reason, path }) => log.warn(`Config option "${path.join('.')}" is not (fully) serializable. ${reason}. Any test runner or checker worker processes might not receive this value as intended.`));
            const p = util_1.PropertyPathBuilder.create().prop('warnings').prop('unserializableOptions').build();
            log.warn(`(disable ${p} to ignore this warning)`);
        }
    }
}
//# sourceMappingURL=options-marker.js.map