"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateOptions = exports.defaultOptions = exports.OptionsValidator = void 0;
const tslib_1 = require("tslib");
const os_1 = (0, tslib_1.__importDefault)(require("os"));
const glob_1 = require("glob");
const ajv_1 = (0, tslib_1.__importDefault)(require("ajv"));
const core_1 = require("@stryker-mutator/api/core");
const plugin_1 = require("@stryker-mutator/api/plugin");
const util_1 = require("@stryker-mutator/util");
const di_1 = require("../di");
const errors_1 = require("../errors");
const command_test_runner_1 = require("../test-runner/command-test-runner");
const input_1 = require("../input");
const validation_errors_1 = require("./validation-errors");
const ajv = new ajv_1.default({ useDefaults: true, allErrors: true, jsPropertySyntax: true, verbose: true, logger: false, strict: false });
class OptionsValidator {
    constructor(schema, log) {
        this.log = log;
        this.validateFn = ajv.compile(schema);
    }
    validate(options) {
        this.removeDeprecatedOptions(options);
        this.schemaValidate(options);
        this.additionalValidation(options);
    }
    removeDeprecatedOptions(rawOptions) {
        var _a, _b;
        if (typeof rawOptions.mutator === 'string') {
            this.log.warn('DEPRECATED. Use of "mutator" as string is no longer needed. You can remove it from your configuration. Stryker now supports mutating of JavaScript and friend files out of the box.');
            delete rawOptions.mutator;
        }
        // @ts-expect-error mutator.name
        if (typeof rawOptions.mutator === 'object' && rawOptions.mutator.name) {
            this.log.warn('DEPRECATED. Use of "mutator.name" is no longer needed. You can remove "mutator.name" from your configuration. Stryker now supports mutating of JavaScript and friend files out of the box.');
            // @ts-expect-error mutator.name
            delete rawOptions.mutator.name;
        }
        if (Object.keys(rawOptions).includes('testFramework')) {
            this.log.warn('DEPRECATED. Use of "testFramework" is no longer needed. You can remove it from your configuration. Your test runner plugin now handles its own test framework integration.');
            delete rawOptions.testFramework;
        }
        if (Array.isArray(rawOptions.transpilers)) {
            const example = rawOptions.transpilers.includes('babel')
                ? 'babel src --out-dir lib'
                : rawOptions.transpilers.includes('typescript')
                    ? 'tsc -b'
                    : rawOptions.transpilers.includes('webpack')
                        ? 'webpack --config webpack.config.js'
                        : 'npm run build';
            this.log.warn(`DEPRECATED. Support for "transpilers" is removed. You can now configure your own "${(0, util_1.propertyPath)('buildCommand')}". For example, ${example}.`);
            delete rawOptions.transpilers;
        }
        if (Array.isArray(rawOptions.files)) {
            const ignorePatternsName = (0, util_1.propertyPath)('ignorePatterns');
            const isString = (uncertain) => typeof uncertain === 'string';
            const files = rawOptions.files.filter(isString);
            const newIgnorePatterns = [
                '**',
                ...files.map((filePattern) => filePattern.startsWith(input_1.IGNORE_PATTERN_CHARACTER) ? filePattern.substr(1) : `${input_1.IGNORE_PATTERN_CHARACTER}${filePattern}`),
            ];
            delete rawOptions.files;
            this.log.warn(`DEPRECATED. Use of "files" is deprecated, please use "${ignorePatternsName}" instead (or remove "files" altogether will probably work as well). For now, rewriting them as ${JSON.stringify(newIgnorePatterns)}. See https://stryker-mutator.io/docs/stryker-js/configuration/#ignorepatterns-string`);
            const existingIgnorePatterns = Array.isArray(rawOptions[ignorePatternsName]) ? rawOptions[ignorePatternsName] : [];
            rawOptions[ignorePatternsName] = [...newIgnorePatterns, ...existingIgnorePatterns];
        }
        // @ts-expect-error jest.enableBail
        if (((_a = rawOptions.jest) === null || _a === void 0 ? void 0 : _a.enableBail) !== undefined) {
            this.log.warn('DEPRECATED. Use of "jest.enableBail" inside deprecated, please use "disableBail" instead. See https://stryker-mutator.io/docs/stryker-js/configuration#disablebail-boolean');
            // @ts-expect-error jest.enableBail
            rawOptions.disableBail = !((_b = rawOptions.jest) === null || _b === void 0 ? void 0 : _b.enableBail);
            // @ts-expect-error jest.enableBail
            delete rawOptions.jest.enableBail;
        }
    }
    additionalValidation(options) {
        const additionalErrors = [];
        if (options.thresholds.high < options.thresholds.low) {
            additionalErrors.push('Config option "thresholds.high" should be higher than "thresholds.low".');
        }
        if (options.maxConcurrentTestRunners !== Number.MAX_SAFE_INTEGER) {
            this.log.warn('DEPRECATED. Use of "maxConcurrentTestRunners" is deprecated. Please use "concurrency" instead.');
            if (!options.concurrency && options.maxConcurrentTestRunners < os_1.default.cpus().length - 1) {
                options.concurrency = options.maxConcurrentTestRunners;
            }
        }
        if (command_test_runner_1.CommandTestRunner.is(options.testRunner)) {
            if (options.testRunnerNodeArgs.length) {
                this.log.warn('Using "testRunnerNodeArgs" together with the "command" test runner is not supported, these arguments will be ignored. You can add your custom arguments by setting the "commandRunner.command" option.');
            }
        }
        options.mutate.forEach((mutateString, index) => {
            const match = input_1.MUTATION_RANGE_REGEX.exec(mutateString);
            if (match) {
                if ((0, glob_1.hasMagic)(mutateString)) {
                    additionalErrors.push(`Config option "mutate[${index}]" is invalid. Cannot combine a glob expression with a mutation range in "${mutateString}".`);
                }
                else {
                    const [_, _fileName, mutationRange, startLine, _startColumn, endLine, _endColumn] = match;
                    const start = parseInt(startLine, 10);
                    const end = parseInt(endLine, 10);
                    if (start < 1) {
                        additionalErrors.push(`Config option "mutate[${index}]" is invalid. Mutation range "${mutationRange}" is invalid, line ${start} does not exist (lines start at 1).`);
                    }
                    if (start > end) {
                        additionalErrors.push(`Config option "mutate[${index}]" is invalid. Mutation range "${mutationRange}" is invalid. The "from" line number (${start}) should be less then the "to" line number (${end}).`);
                    }
                }
            }
        });
        additionalErrors.forEach((error) => this.log.error(error));
        this.throwErrorIfNeeded(additionalErrors);
    }
    schemaValidate(options) {
        if (!this.validateFn(options)) {
            const describedErrors = (0, validation_errors_1.describeErrors)(this.validateFn.errors);
            describedErrors.forEach((error) => this.log.error(error));
            this.throwErrorIfNeeded(describedErrors);
        }
    }
    throwErrorIfNeeded(errors) {
        if (errors.length > 0) {
            throw new errors_1.ConfigError(errors.length === 1 ? 'Please correct this configuration error and try again.' : 'Please correct these configuration errors and try again.');
        }
    }
}
exports.OptionsValidator = OptionsValidator;
OptionsValidator.inject = (0, plugin_1.tokens)(di_1.coreTokens.validationSchema, plugin_1.commonTokens.logger);
function defaultOptions() {
    const options = {};
    const validator = new OptionsValidator(core_1.strykerCoreSchema, util_1.noopLogger);
    validator.validate(options);
    return options;
}
exports.defaultOptions = defaultOptions;
validateOptions.inject = (0, plugin_1.tokens)(plugin_1.commonTokens.options, di_1.coreTokens.optionsValidator);
function validateOptions(options, optionsValidator) {
    optionsValidator.validate(options);
    return (0, util_1.deepFreeze)(options);
}
exports.validateOptions = validateOptions;
//# sourceMappingURL=options-validator.js.map