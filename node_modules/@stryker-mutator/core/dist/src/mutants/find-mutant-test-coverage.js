"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findMutantTestCoverage = void 0;
const plugin_1 = require("@stryker-mutator/api/plugin");
const di_1 = require("../di");
findMutantTestCoverage.inject = (0, plugin_1.tokens)(di_1.coreTokens.dryRunResult, di_1.coreTokens.mutants, di_1.coreTokens.reporter, plugin_1.commonTokens.logger);
function findMutantTestCoverage(dryRunResult, mutants, reporter, logger) {
    const mutantTestCoverage = mapToMutantTestCoverage(dryRunResult, mutants, logger);
    reporter.onAllMutantsMatchedWithTests(mutantTestCoverage);
    return mutantTestCoverage;
}
exports.findMutantTestCoverage = findMutantTestCoverage;
function mapToMutantTestCoverage(dryRunResult, mutants, logger) {
    var _a;
    const testsByMutantId = findTestsByMutant((_a = dryRunResult.mutantCoverage) === null || _a === void 0 ? void 0 : _a.perTest, dryRunResult.tests, logger);
    const hitsByMutantId = findHitsByMutantId(dryRunResult.mutantCoverage);
    const timeSpentAllTests = calculateTotalTime(dryRunResult.tests);
    const mutantCoverage = mutants.map((mutant) => {
        const hitCount = hitsByMutantId.get(mutant.id);
        if (mutant.status) {
            return {
                ...mutant,
                static: false,
                hitCount,
                estimatedNetTime: 0,
            };
        }
        else if (!dryRunResult.mutantCoverage || dryRunResult.mutantCoverage.static[mutant.id] > 0) {
            // When there is static coverage for this mutant, it is a static mutant.
            return {
                ...mutant,
                estimatedNetTime: timeSpentAllTests,
                hitCount,
                coveredBy: undefined,
                static: true,
            };
        }
        else {
            // If no static coverage, but there is test coverage, it is a non-static, covered mutant
            const tests = testsByMutantId.get(mutant.id);
            if (tests && tests.size > 0) {
                return {
                    ...mutant,
                    estimatedNetTime: calculateTotalTime(tests),
                    hitCount,
                    coveredBy: toTestIds(tests),
                    static: false,
                };
            }
            else {
                // Otherwise it is has no coverage
                return {
                    ...mutant,
                    estimatedNetTime: 0,
                    hitCount,
                    coveredBy: [],
                    static: false,
                };
            }
        }
    });
    return mutantCoverage;
}
function findTestsByMutant(coveragePerTest, allTests, logger) {
    const testsByMutantId = new Map();
    coveragePerTest &&
        Object.entries(coveragePerTest).forEach(([testId, mutantCoverage]) => {
            const foundTest = allTests.find((test) => test.id === testId);
            if (!foundTest) {
                logger.debug(`Found test with id "${testId}" in coverage data, but not in the test results of the dry run. Not taking coverage data for this test into account`);
                return;
            }
            Object.entries(mutantCoverage).forEach(([mutantId, count]) => {
                if (count) {
                    let tests = testsByMutantId.get(mutantId);
                    if (!tests) {
                        tests = new Set();
                        testsByMutantId.set(mutantId, tests);
                    }
                    tests.add(foundTest);
                }
            });
        });
    return testsByMutantId;
}
function calculateTotalTime(testResults) {
    let total = 0;
    for (const test of testResults) {
        total += test.timeSpentMs;
    }
    return total;
}
function toTestIds(testResults) {
    const result = [];
    for (const test of testResults) {
        result.push(test.id);
    }
    return result;
}
/**
 * Find the number of hits per mutant. This is the total amount of times the mutant was executed during the dry test run.
 * @param coverageData The coverage data from the initial test run
 * @returns The hits by mutant id
 */
function findHitsByMutantId(coverageData) {
    const hitsByMutant = new Map();
    if (coverageData) {
        // We don't care about the exact tests in this case, just the total number of hits
        const coverageResultsPerMutant = [coverageData.static, ...Object.values(coverageData.perTest)];
        coverageResultsPerMutant.forEach((coverageByMutantId) => {
            Object.entries(coverageByMutantId).forEach(([mutantId, count]) => {
                var _a;
                hitsByMutant.set(mutantId, ((_a = hitsByMutant.get(mutantId)) !== null && _a !== void 0 ? _a : 0) + count);
            });
        });
    }
    return hitsByMutant;
}
//# sourceMappingURL=find-mutant-test-coverage.js.map