"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChildProcessProxy = void 0;
const tslib_1 = require("tslib");
const child_process_1 = (0, tslib_1.__importDefault)(require("child_process"));
const os_1 = (0, tslib_1.__importDefault)(require("os"));
const util_1 = require("@stryker-mutator/util");
const log4js_1 = require("log4js");
const object_utils_1 = require("../utils/object-utils");
const string_builder_1 = require("../utils/string-builder");
const string_utils_1 = require("../utils/string-utils");
const child_process_crashed_error_1 = require("./child-process-crashed-error");
const message_protocol_1 = require("./message-protocol");
const out_of_memory_error_1 = require("./out-of-memory-error");
const BROKEN_PIPE_ERROR_CODE = 'EPIPE';
const IPC_CHANNEL_CLOSED_ERROR_CODE = 'ERR_IPC_CHANNEL_CLOSED';
const TIMEOUT_FOR_DISPOSE = 2000;
class ChildProcessProxy {
    constructor(requirePath, requireName, loggingContext, options, additionalInjectableValues, workingDirectory, execArgv) {
        this.workerTasks = [];
        this.log = (0, log4js_1.getLogger)(ChildProcessProxy.name);
        this.stdoutBuilder = new string_builder_1.StringBuilder();
        this.stderrBuilder = new string_builder_1.StringBuilder();
        this.isDisposed = false;
        this.handleUnexpectedExit = (code, signal) => {
            this.isDisposed = true;
            const output = string_builder_1.StringBuilder.concat(this.stderrBuilder, this.stdoutBuilder);
            if (processOutOfMemory()) {
                this.currentError = new out_of_memory_error_1.OutOfMemoryError(this.worker.pid, code);
                this.log.warn(`Child process [pid ${this.currentError.pid}] ran out of memory. Stdout and stderr are logged on debug level.`);
                this.log.debug(stdoutAndStderr());
            }
            else {
                this.currentError = new child_process_crashed_error_1.ChildProcessCrashedError(this.worker.pid, `Child process [pid ${this.worker.pid}] exited unexpectedly with exit code ${code} (${signal || 'without signal'}). ${stdoutAndStderr()}`, code, signal);
                this.log.warn(this.currentError.message, this.currentError);
            }
            this.reportError(this.currentError);
            function processOutOfMemory() {
                return output.includes('JavaScript heap out of memory') || output.includes('FatalProcessOutOfMemory');
            }
            function stdoutAndStderr() {
                if (output.length) {
                    return `Last part of stdout and stderr was:${os_1.default.EOL}${(0, string_utils_1.padLeft)(output)}`;
                }
                else {
                    return 'Stdout and stderr were empty.';
                }
            }
        };
        this.handleError = (error) => {
            if (this.innerProcessIsCrashed(error)) {
                this.log.warn(`Child process [pid ${this.worker.pid}] has crashed. See other warning messages for more info.`, error);
                this.reportError(new child_process_crashed_error_1.ChildProcessCrashedError(this.worker.pid, `Child process [pid ${this.worker.pid}] has crashed`, undefined, undefined, error));
            }
            else {
                this.reportError(error);
            }
        };
        this.worker = child_process_1.default.fork(require.resolve('./child-process-proxy-worker'), { silent: true, execArgv });
        this.initTask = new util_1.Task();
        this.log.debug('Started %s in child process %s%s', requireName, this.worker.pid, execArgv.length ? ` (using args ${execArgv.join(' ')})` : '');
        this.send({
            additionalInjectableValues,
            kind: message_protocol_1.WorkerMessageKind.Init,
            loggingContext,
            options,
            requireName,
            requirePath,
            workingDirectory,
        });
        this.listenForMessages();
        this.listenToStdoutAndStderr();
        // Listen to `close`, not `exit`, see https://github.com/stryker-mutator/stryker-js/issues/1634
        this.worker.on('close', this.handleUnexpectedExit);
        this.worker.on('error', this.handleError);
        this.proxy = this.initProxy();
    }
    /**
     * @description Creates a proxy where each function of the object created using the constructorFunction arg is ran inside of a child process
     */
    static create(requirePath, loggingContext, options, additionalInjectableValues, workingDirectory, injectableClass, execArgv) {
        return new ChildProcessProxy(requirePath, injectableClass.name, loggingContext, options, additionalInjectableValues, workingDirectory, execArgv);
    }
    send(message) {
        this.worker.send((0, string_utils_1.serialize)(message));
    }
    initProxy() {
        // This proxy is a genuine javascript `Proxy` class
        // More info: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy
        const self = this;
        return new Proxy({}, {
            get(_, propertyKey) {
                if (typeof propertyKey === 'string') {
                    return self.forward(propertyKey);
                }
                else {
                    return undefined;
                }
            },
        });
    }
    forward(methodName) {
        return async (...args) => {
            if (this.currentError) {
                return Promise.reject(this.currentError);
            }
            else {
                const workerTask = new util_1.Task();
                const correlationId = this.workerTasks.push(workerTask) - 1;
                this.initTask.promise.then(() => {
                    this.send({
                        args,
                        correlationId,
                        kind: message_protocol_1.WorkerMessageKind.Call,
                        methodName,
                    });
                });
                return workerTask.promise;
            }
        };
    }
    listenForMessages() {
        this.worker.on('message', (serializedMessage) => {
            const message = (0, string_utils_1.deserialize)(serializedMessage);
            switch (message.kind) {
                case message_protocol_1.ParentMessageKind.Initialized:
                    this.initTask.resolve(undefined);
                    break;
                case message_protocol_1.ParentMessageKind.Result:
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                    this.workerTasks[message.correlationId].resolve(message.result);
                    delete this.workerTasks[message.correlationId];
                    break;
                case message_protocol_1.ParentMessageKind.Rejection:
                    this.workerTasks[message.correlationId].reject(new Error(message.error));
                    delete this.workerTasks[message.correlationId];
                    break;
                case message_protocol_1.ParentMessageKind.DisposeCompleted:
                    if (this.disposeTask) {
                        this.disposeTask.resolve(undefined);
                    }
                    break;
                default:
                    this.logUnidentifiedMessage(message);
                    break;
            }
        });
    }
    listenToStdoutAndStderr() {
        const handleData = (builder) => (data) => {
            const output = data.toString();
            builder.append(output);
            if (this.log.isTraceEnabled()) {
                this.log.trace(output);
            }
        };
        if (this.worker.stdout) {
            this.worker.stdout.on('data', handleData(this.stdoutBuilder));
        }
        if (this.worker.stderr) {
            this.worker.stderr.on('data', handleData(this.stderrBuilder));
        }
    }
    get stdout() {
        return this.stdoutBuilder.toString();
    }
    get stderr() {
        return this.stderrBuilder.toString();
    }
    reportError(error) {
        this.workerTasks.filter((task) => !task.isCompleted).forEach((task) => task.reject(error));
    }
    innerProcessIsCrashed(error) {
        return (0, util_1.isErrnoException)(error) && (error.code === BROKEN_PIPE_ERROR_CODE || error.code === IPC_CHANNEL_CLOSED_ERROR_CODE);
    }
    async dispose() {
        if (!this.isDisposed) {
            this.worker.removeListener('close', this.handleUnexpectedExit);
            this.isDisposed = true;
            this.log.debug('Disposing of worker process %s', this.worker.pid);
            this.disposeTask = new util_1.ExpirableTask(TIMEOUT_FOR_DISPOSE);
            this.send({ kind: message_protocol_1.WorkerMessageKind.Dispose });
            try {
                await this.disposeTask.promise;
            }
            finally {
                this.log.debug('Kill %s', this.worker.pid);
                await (0, object_utils_1.kill)(this.worker.pid);
            }
        }
    }
    logUnidentifiedMessage(message) {
        this.log.error(`Received unidentified message ${message}`);
    }
}
exports.ChildProcessProxy = ChildProcessProxy;
//# sourceMappingURL=child-process-proxy.js.map