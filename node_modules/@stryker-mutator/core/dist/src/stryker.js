"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Stryker = void 0;
const typed_inject_1 = require("typed-inject");
const plugin_1 = require("@stryker-mutator/api/plugin");
const logging_1 = require("./logging");
const process_1 = require("./process");
const di_1 = require("./di");
const errors_1 = require("./errors");
/**
 * The main Stryker class.
 * It provides a single `runMutationTest()` function which runs mutation testing:
 */
class Stryker {
    /**
     * @constructor
     * @param cliOptions The cli options.
     * @param injectorFactory The injector factory, for testing purposes only
     */
    constructor(cliOptions, injectorFactory = typed_inject_1.createInjector) {
        this.cliOptions = cliOptions;
        this.injectorFactory = injectorFactory;
    }
    async runMutationTest() {
        const rootInjector = this.injectorFactory();
        const loggerProvider = (0, di_1.provideLogger)(rootInjector);
        try {
            // 1. Prepare. Load Stryker configuration, load the input files and starts the logging server
            const prepareExecutor = loggerProvider.provideValue(di_1.coreTokens.cliOptions, this.cliOptions).injectClass(process_1.PrepareExecutor);
            const mutantInstrumenterInjector = await prepareExecutor.execute();
            try {
                // 2. Mutate and instrument the files and write to the sandbox.
                const mutantInstrumenter = mutantInstrumenterInjector.injectClass(process_1.MutantInstrumenterExecutor);
                const dryRunExecutorInjector = await mutantInstrumenter.execute();
                // 3. Perform a 'dry run' (initial test run). Runs the tests without active mutants and collects coverage.
                const dryRunExecutor = dryRunExecutorInjector.injectClass(process_1.DryRunExecutor);
                const mutationRunExecutorInjector = await dryRunExecutor.execute();
                // 4. Actual mutation testing. Will check every mutant and if valid run it in an available test runner.
                const mutationRunExecutor = mutationRunExecutorInjector.injectClass(process_1.MutationTestExecutor);
                const mutantResults = await mutationRunExecutor.execute();
                return mutantResults;
            }
            catch (error) {
                const log = loggerProvider.resolve(plugin_1.commonTokens.getLogger)(Stryker.name);
                log.debug('Not removing the temp dir because an error occurred');
                mutantInstrumenterInjector.resolve(di_1.coreTokens.temporaryDirectory).removeDuringDisposal = false;
                throw error;
            }
        }
        catch (error) {
            const log = loggerProvider.resolve(plugin_1.commonTokens.getLogger)(Stryker.name);
            const cause = (0, errors_1.retrieveCause)(error);
            if (cause instanceof errors_1.ConfigError) {
                log.error(cause.message);
            }
            else {
                log.error('Unexpected error occurred while running Stryker', error);
                log.info('This might be a known problem with a solution documented in our troubleshooting guide.');
                log.info('You can find it at https://stryker-mutator.io/docs/stryker-js/troubleshooting/');
                if (!log.isTraceEnabled()) {
                    log.info('Still having trouble figuring out what went wrong? Try `npx stryker run --fileLogLevel trace --logLevel debug` to get some more info.');
                }
            }
            throw cause;
        }
        finally {
            await rootInjector.dispose();
            await logging_1.LogConfigurator.shutdown();
        }
    }
}
exports.Stryker = Stryker;
//# sourceMappingURL=stryker.js.map