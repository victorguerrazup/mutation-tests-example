"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CheckerRetryDecorator = void 0;
const child_process_crashed_error_1 = require("../child-proxy/child-process-crashed-error");
const out_of_memory_error_1 = require("../child-proxy/out-of-memory-error");
const concurrent_1 = require("../concurrent");
class CheckerRetryDecorator extends concurrent_1.ResourceDecorator {
    constructor(producer, log) {
        super(producer);
        this.log = log;
    }
    async check(mutant) {
        try {
            return await this.innerResource.check(mutant);
        }
        catch (error) {
            if (error instanceof child_process_crashed_error_1.ChildProcessCrashedError) {
                if (error instanceof out_of_memory_error_1.OutOfMemoryError) {
                    this.log.warn(`Checker process [${error.pid}] ran out of memory. Retrying in a new process.`);
                }
                else {
                    this.log.warn(`Checker process [${error.pid}] crashed with exit code ${error.exitCode}. Retrying in a new process.`, error);
                }
                await this.recover();
                return this.innerResource.check(mutant);
            }
            else {
                throw error; //oops
            }
        }
    }
}
exports.CheckerRetryDecorator = CheckerRetryDecorator;
//# sourceMappingURL=checker-retry-decorator.js.map