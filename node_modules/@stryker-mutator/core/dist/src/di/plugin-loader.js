"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PluginLoader = void 0;
const tslib_1 = require("tslib");
const path_1 = (0, tslib_1.__importDefault)(require("path"));
const fs_1 = require("fs");
const plugin_1 = require("@stryker-mutator/api/plugin");
const typed_inject_1 = require("typed-inject");
const file_utils_1 = require("../utils/file-utils");
const coreTokens = (0, tslib_1.__importStar)(require("./core-tokens"));
const IGNORED_PACKAGES = ['core', 'api', 'util'];
class PluginLoader {
    constructor(log, pluginDescriptors) {
        this.log = log;
        this.pluginDescriptors = pluginDescriptors;
        this.pluginsByKind = new Map();
        this.contributedValidationSchemas = [];
    }
    load() {
        this.resolvePluginModules().forEach((moduleName) => {
            this.requirePlugin(moduleName);
        });
    }
    resolveValidationSchemaContributions() {
        return this.contributedValidationSchemas;
    }
    resolve(kind, name) {
        const plugins = this.pluginsByKind.get(kind);
        if (plugins) {
            const pluginFound = plugins.find((plugin) => plugin.name.toLowerCase() === name.toLowerCase());
            if (pluginFound) {
                return pluginFound;
            }
            else {
                throw new Error(`Cannot load ${kind} plugin "${name}". Did you forget to install it? Loaded ${kind} plugins were: ${plugins.map((p) => p.name).join(', ')}`);
            }
        }
        else {
            throw new Error(`Cannot load ${kind} plugin "${name}". In fact, no ${kind} plugins were loaded. Did you forget to install it?`);
        }
    }
    resolveAll(kind) {
        var _a;
        const plugins = (_a = this.pluginsByKind.get(kind)) !== null && _a !== void 0 ? _a : [];
        return plugins;
    }
    resolvePluginModules() {
        const modules = [];
        this.pluginDescriptors.forEach((pluginExpression) => {
            if (typeof pluginExpression === 'string') {
                if (pluginExpression.includes('*')) {
                    // Plugin directory is the node_modules folder of the module that installed stryker
                    // So if current __dirname is './@stryker-mutator/core/dist/src/di' so 4 directories above
                    const pluginDirectory = path_1.default.dirname(path_1.default.resolve(__dirname, '..', '..', '..', '..', '..', pluginExpression));
                    const regexp = new RegExp('^' + path_1.default.basename(pluginExpression).replace('*', '.*'));
                    this.log.debug('Loading %s from %s', pluginExpression, pluginDirectory);
                    const plugins = (0, fs_1.readdirSync)(pluginDirectory)
                        .filter((pluginName) => !IGNORED_PACKAGES.includes(pluginName) && regexp.test(pluginName))
                        .map((pluginName) => path_1.default.resolve(pluginDirectory, pluginName));
                    if (plugins.length === 0) {
                        this.log.debug('Expression %s not resulted in plugins to load', pluginExpression);
                    }
                    plugins
                        .map((plugin) => {
                        this.log.debug('Loading plugin "%s" (matched with expression %s)', plugin, pluginExpression);
                        return plugin;
                    })
                        .forEach((p) => modules.push(p));
                }
                else {
                    modules.push(pluginExpression);
                }
            }
            else {
                this.log.warn('Ignoring plugin %s, as its not a string type', pluginExpression);
            }
        });
        return modules;
    }
    requirePlugin(name) {
        this.log.debug(`Loading plugins ${name}`);
        try {
            const module = (0, file_utils_1.importModule)(name);
            if (this.isPluginModule(module)) {
                module.strykerPlugins.forEach((plugin) => this.loadPlugin(plugin));
            }
            if (this.hasValidationSchemaContribution(module)) {
                this.contributedValidationSchemas.push(module.strykerValidationSchema);
            }
        }
        catch (e) {
            if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {
                this.log.warn('Cannot find plugin "%s".\n  Did you forget to install it ?\n' + '  npm install %s --save-dev', name, name);
            }
            else {
                this.log.warn('Error during loading "%s" plugin:\n  %s', name, e.message);
            }
        }
    }
    loadPlugin(plugin) {
        let plugins = this.pluginsByKind.get(plugin.kind);
        if (!plugins) {
            plugins = [];
            this.pluginsByKind.set(plugin.kind, plugins);
        }
        plugins.push(plugin);
    }
    isPluginModule(module) {
        const pluginModule = module;
        return (pluginModule === null || pluginModule === void 0 ? void 0 : pluginModule.strykerPlugins) && Array.isArray(pluginModule.strykerPlugins);
    }
    hasValidationSchemaContribution(module) {
        const pluginModule = module;
        return (pluginModule === null || pluginModule === void 0 ? void 0 : pluginModule.strykerValidationSchema) && typeof pluginModule.strykerValidationSchema === 'object';
    }
}
exports.PluginLoader = PluginLoader;
PluginLoader.inject = (0, typed_inject_1.tokens)(plugin_1.commonTokens.logger, coreTokens.pluginDescriptors);
//# sourceMappingURL=plugin-loader.js.map