"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RetryRejectedDecorator = exports.MAX_RETRIES = void 0;
const test_runner_1 = require("@stryker-mutator/api/test-runner");
const util_1 = require("@stryker-mutator/util");
const log4js_1 = require("log4js");
const out_of_memory_error_1 = require("../child-proxy/out-of-memory-error");
const test_runner_decorator_1 = require("./test-runner-decorator");
const ERROR_MESSAGE = 'Test runner crashed. Tried twice to restart it without any luck. Last time the error message was: ';
exports.MAX_RETRIES = 2;
/**
 * Implements the retry functionality whenever an internal test runner rejects a promise.
 */
class RetryRejectedDecorator extends test_runner_decorator_1.TestRunnerDecorator {
    constructor() {
        super(...arguments);
        this.log = (0, log4js_1.getLogger)(RetryRejectedDecorator.name);
    }
    async dryRun(options) {
        const result = await this.run(() => super.dryRun(options));
        if (typeof result === 'string') {
            return {
                status: test_runner_1.DryRunStatus.Error,
                errorMessage: result,
            };
        }
        else {
            return result;
        }
    }
    async mutantRun(options) {
        const result = await this.run(() => super.mutantRun(options));
        if (typeof result === 'string') {
            return {
                status: test_runner_1.MutantRunStatus.Error,
                errorMessage: result,
            };
        }
        else {
            return result;
        }
    }
    async run(actRun, attemptsLeft = exports.MAX_RETRIES, lastError) {
        if (attemptsLeft > 0) {
            try {
                return await actRun();
            }
            catch (error) {
                if (error instanceof out_of_memory_error_1.OutOfMemoryError) {
                    this.log.info("Test runner process [%s] ran out of memory. You probably have a memory leak in your tests. Don't worry, Stryker will restart the process, but you might want to investigate this later, because this decreases performance.", error.pid);
                }
                await this.recover();
                return this.run(actRun, attemptsLeft - 1, error);
            }
        }
        else {
            await this.recover();
            return `${ERROR_MESSAGE}${(0, util_1.errorToString)(lastError)}`;
        }
    }
}
exports.RetryRejectedDecorator = RetryRejectedDecorator;
//# sourceMappingURL=retry-rejected-decorator.js.map