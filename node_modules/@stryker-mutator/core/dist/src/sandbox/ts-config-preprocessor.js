"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TSConfigPreprocessor = void 0;
const tslib_1 = require("tslib");
const path_1 = (0, tslib_1.__importDefault)(require("path"));
const core_1 = require("@stryker-mutator/api/core");
const plugin_1 = require("@stryker-mutator/api/plugin");
/**
 * A helper class that rewrites `references` and `extends` file paths if they end up falling outside of the sandbox.
 * @example
 * {
 *   "extends": "../../tsconfig.settings.json",
 *   "references": {
 *      "path": "../model"
 *   }
 * }
 * becomes:
 * {
 *   "extends": "../../../../tsconfig.settings.json",
 *   "references": {
 *      "path": "../../../model"
 *   }
 * }
 */
class TSConfigPreprocessor {
    constructor(log, options) {
        this.log = log;
        this.options = options;
        this.touched = [];
        this.fs = new Map();
    }
    async preprocess(input) {
        if (this.options.inPlace) {
            // If stryker is running 'inPlace', we don't have to change the tsconfig file
            return input;
        }
        else {
            const tsconfigFile = path_1.default.resolve(this.options.tsconfigFile);
            if (input.find((file) => file.name === tsconfigFile)) {
                this.fs.clear();
                input.forEach((file) => {
                    this.fs.set(file.name, file);
                });
                await this.rewriteTSConfigFile(tsconfigFile);
                return [...this.fs.values()];
            }
            else {
                return input;
            }
        }
    }
    async rewriteTSConfigFile(tsconfigFileName) {
        if (!this.touched.includes(tsconfigFileName)) {
            this.touched.push(tsconfigFileName);
            const tsconfigFile = this.fs.get(tsconfigFileName);
            if (tsconfigFile) {
                this.log.debug('Rewriting file %s', tsconfigFile);
                const ts = await Promise.resolve().then(() => (0, tslib_1.__importStar)(require('typescript')));
                const { config } = ts.parseConfigFileTextToJson(tsconfigFile.name, tsconfigFile.textContent);
                if (config) {
                    await this.rewriteExtends(config, tsconfigFileName);
                    await this.rewriteProjectReferences(config, tsconfigFileName);
                    this.rewriteFileArrayProperty(config, tsconfigFileName, 'include');
                    this.rewriteFileArrayProperty(config, tsconfigFileName, 'exclude');
                    this.rewriteFileArrayProperty(config, tsconfigFileName, 'files');
                    this.fs.set(tsconfigFileName, new core_1.File(tsconfigFileName, JSON.stringify(config, null, 2)));
                }
            }
        }
    }
    async rewriteExtends(config, tsconfigFileName) {
        const extend = config.extends;
        if (typeof extend === 'string') {
            const rewritten = this.tryRewriteReference(extend, tsconfigFileName);
            if (rewritten) {
                config.extends = rewritten;
            }
            else {
                await this.rewriteTSConfigFile(path_1.default.resolve(path_1.default.dirname(tsconfigFileName), extend));
            }
        }
    }
    rewriteFileArrayProperty(config, tsconfigFileName, prop) {
        const fileArray = config[prop];
        if (Array.isArray(fileArray)) {
            config[prop] = fileArray.map((pattern) => {
                const rewritten = this.tryRewriteReference(pattern, tsconfigFileName);
                if (rewritten) {
                    return rewritten;
                }
                else {
                    return pattern;
                }
            });
        }
    }
    async rewriteProjectReferences(config, originTSConfigFileName) {
        const ts = await Promise.resolve().then(() => (0, tslib_1.__importStar)(require('typescript')));
        if (Array.isArray(config.references)) {
            for (const reference of config.references) {
                const referencePath = ts.resolveProjectReferencePath(reference);
                const rewritten = this.tryRewriteReference(referencePath, originTSConfigFileName);
                if (rewritten) {
                    reference.path = rewritten;
                }
                else {
                    await this.rewriteTSConfigFile(path_1.default.resolve(path_1.default.dirname(originTSConfigFileName), referencePath));
                }
            }
        }
    }
    tryRewriteReference(reference, originTSConfigFileName) {
        const dirName = path_1.default.dirname(originTSConfigFileName);
        const fileName = path_1.default.resolve(dirName, reference);
        const relativeToSandbox = path_1.default.relative(process.cwd(), fileName);
        if (relativeToSandbox.startsWith('..')) {
            return this.join('..', '..', reference);
        }
        return false;
    }
    join(...pathSegments) {
        return pathSegments.map((segment) => segment.replace(/\\/g, '/')).join('/');
    }
}
exports.TSConfigPreprocessor = TSConfigPreprocessor;
TSConfigPreprocessor.inject = (0, plugin_1.tokens)(plugin_1.commonTokens.logger, plugin_1.commonTokens.options);
//# sourceMappingURL=ts-config-preprocessor.js.map