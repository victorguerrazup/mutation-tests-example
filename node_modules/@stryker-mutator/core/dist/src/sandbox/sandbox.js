"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sandbox = void 0;
const tslib_1 = require("tslib");
const path_1 = (0, tslib_1.__importDefault)(require("path"));
const fs_1 = require("fs");
const npm_run_path_1 = (0, tslib_1.__importDefault)(require("npm-run-path"));
const util_1 = require("@stryker-mutator/util");
const plugin_1 = require("@stryker-mutator/api/plugin");
const operators_1 = require("rxjs/operators");
const rxjs_1 = require("rxjs");
const file_utils_1 = require("../utils/file-utils");
const di_1 = require("../di");
class Sandbox {
    constructor(options, log, temporaryDirectory, files, exec, unexpectedExitHandler) {
        this.options = options;
        this.log = log;
        this.files = files;
        this.exec = exec;
        this.fileMap = new Map();
        this.backupDirectory = '';
        if (options.inPlace) {
            this.workingDirectory = process.cwd();
            this.backupDirectory = temporaryDirectory.createRandomDirectory('backup');
            this.log.info('In place mode is enabled, Stryker will be overriding YOUR files. Find your backup at: %s', path_1.default.relative(process.cwd(), this.backupDirectory));
            unexpectedExitHandler.registerHandler(this.dispose.bind(this, true));
        }
        else {
            this.workingDirectory = temporaryDirectory.createRandomDirectory('sandbox');
            this.log.debug('Creating a sandbox for files in %s', this.workingDirectory);
        }
    }
    async init() {
        await this.fillSandbox();
        await this.runBuildCommand();
        await this.symlinkNodeModulesIfNeeded();
    }
    sandboxFileFor(fileName) {
        const sandboxFileName = this.fileMap.get(fileName);
        if (sandboxFileName === undefined) {
            throw new Error(`Cannot find sandbox file for ${fileName}`);
        }
        return sandboxFileName;
    }
    originalFileFor(sandboxFileName) {
        return path_1.default.resolve(sandboxFileName).replace(this.workingDirectory, process.cwd());
    }
    fillSandbox() {
        const files$ = (0, rxjs_1.from)(this.files).pipe((0, operators_1.mergeMap)((file) => this.fillFile(file), file_utils_1.MAX_CONCURRENT_FILE_IO), (0, operators_1.toArray)());
        return (0, rxjs_1.lastValueFrom)(files$);
    }
    async runBuildCommand() {
        if (this.options.buildCommand) {
            const env = npm_run_path_1.default.env();
            this.log.info('Running build command "%s" in "%s".', this.options.buildCommand, this.workingDirectory);
            this.log.debug('(using PATH: %s)', env.PATH);
            await this.exec.command(this.options.buildCommand, { cwd: this.workingDirectory, env });
        }
    }
    async symlinkNodeModulesIfNeeded() {
        this.log.debug('Start symlink node_modules');
        if (this.options.symlinkNodeModules && !this.options.inPlace) {
            // TODO: Change with this.options.basePath when we have it
            const basePath = process.cwd();
            const nodeModulesList = await (0, file_utils_1.findNodeModulesList)(basePath, this.options.tempDirName);
            if (nodeModulesList.length > 0) {
                for (const nodeModules of nodeModulesList) {
                    this.log.debug(`Create symlink from ${path_1.default.resolve(nodeModules)} to ${path_1.default.join(this.workingDirectory, nodeModules)}`);
                    await (0, file_utils_1.symlinkJunction)(path_1.default.resolve(nodeModules), path_1.default.join(this.workingDirectory, nodeModules)).catch((error) => {
                        if (error.code === 'EEXIST') {
                            this.log.warn((0, util_1.normalizeWhitespaces)(`Could not symlink "${nodeModules}" in sandbox directory,
              it is already created in the sandbox. Please remove the node_modules from your sandbox files.
              Alternatively, set \`symlinkNodeModules\` to \`false\` to disable this warning.`));
                        }
                        else {
                            this.log.warn(`Unexpected error while trying to symlink "${nodeModules}" in sandbox directory.`, error);
                        }
                    });
                }
            }
            else {
                this.log.warn(`Could not find a node_modules folder to symlink into the sandbox directory. Search "${basePath}" and its parent directories`);
            }
        }
    }
    async fillFile(file) {
        const relativePath = path_1.default.relative(process.cwd(), file.name);
        if (this.options.inPlace) {
            this.fileMap.set(file.name, file.name);
            const originalContent = await fs_1.promises.readFile(file.name);
            if (!originalContent.equals(file.content)) {
                // File is changed (either mutated or by a preprocessor), make a backup and replace in-place
                const backupFileName = path_1.default.join(this.backupDirectory, relativePath);
                await (0, file_utils_1.mkdirp)(path_1.default.dirname(backupFileName));
                await fs_1.promises.writeFile(backupFileName, originalContent);
                this.log.debug('Stored backup file at %s', backupFileName);
                await fs_1.promises.writeFile(file.name, file.content);
            }
        }
        else {
            const folderName = path_1.default.join(this.workingDirectory, path_1.default.dirname(relativePath));
            await (0, file_utils_1.mkdirp)(folderName);
            const targetFileName = path_1.default.join(folderName, path_1.default.basename(relativePath));
            this.fileMap.set(file.name, targetFileName);
            await fs_1.promises.writeFile(targetFileName, file.content);
        }
    }
    dispose(unexpected = false) {
        if (this.backupDirectory) {
            if (unexpected) {
                console.error(`Detecting unexpected exit, recovering original files from ${path_1.default.relative(process.cwd(), this.backupDirectory)}`);
            }
            else {
                this.log.info(`Resetting your original files from ${path_1.default.relative(process.cwd(), this.backupDirectory)}.`);
            }
            (0, file_utils_1.moveDirectoryRecursiveSync)(this.backupDirectory, this.workingDirectory);
        }
    }
}
exports.Sandbox = Sandbox;
Sandbox.inject = (0, plugin_1.tokens)(plugin_1.commonTokens.options, plugin_1.commonTokens.logger, di_1.coreTokens.temporaryDirectory, di_1.coreTokens.files, di_1.coreTokens.execa, di_1.coreTokens.unexpectedExitRegistry);
//# sourceMappingURL=sandbox.js.map