"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Pool = exports.createCheckerPool = exports.createTestRunnerPool = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const util_1 = require("@stryker-mutator/util");
const typed_inject_1 = require("typed-inject");
const di_1 = require("../di");
const MAX_CONCURRENT_INIT = 2;
createTestRunnerPool.inject = (0, typed_inject_1.tokens)(di_1.coreTokens.testRunnerFactory, di_1.coreTokens.testRunnerConcurrencyTokens);
function createTestRunnerPool(factory, concurrencyToken$) {
    return new Pool(factory, concurrencyToken$);
}
exports.createTestRunnerPool = createTestRunnerPool;
createCheckerPool.inject = (0, typed_inject_1.tokens)(di_1.coreTokens.checkerFactory, di_1.coreTokens.checkerConcurrencyTokens);
function createCheckerPool(factory, concurrencyToken$) {
    return new Pool(factory, concurrencyToken$);
}
exports.createCheckerPool = createCheckerPool;
/**
 * Represents a pool of resources. Use `schedule` to schedule work to be executed on the resources.
 * The pool will automatically recycle the resources, but will make sure only one task is executed
 * on one resource at any one time. Creates as many resources as the concurrency tokens allow.
 * Also takes care of the initialing of the resources (with `init()`)
 */
class Pool {
    constructor(factory, concurrencyToken$) {
        this.createdResources = [];
        this.isDisposed = false;
        this.resource$ = concurrencyToken$.pipe((0, operators_1.mergeMap)(async () => {
            var _a;
            if (this.isDisposed) {
                return null;
            }
            else {
                const resource = factory();
                this.createdResources.push(resource);
                await ((_a = resource.init) === null || _a === void 0 ? void 0 : _a.call(resource));
                return resource;
            }
        }, MAX_CONCURRENT_INIT), (0, operators_1.filter)(util_1.notEmpty), 
        // We use share replay here. This way the dry run can use a test runner that is later reused during mutation testing
        // https://www.learnrxjs.io/learn-rxjs/operators/multicasting/sharereplay
        (0, operators_1.shareReplay)());
    }
    /**
     * Returns a promise that resolves if all concurrency tokens have resulted in initialized resources.
     * This is optional, resources will get initialized either way.
     */
    async init() {
        await (0, rxjs_1.lastValueFrom)(this.resource$);
    }
    /**
     * Schedules a task to be executed on resources in the pool. Each input is paired with a resource, which allows async work to be done.
     * @param input$ The inputs to pair up with a resource.
     * @param task The task to execute on each resource
     */
    schedule(input$, task) {
        const recycleBin = new rxjs_1.Subject();
        const resource$ = (0, rxjs_1.merge)(recycleBin, this.resource$);
        return (0, rxjs_1.zip)(resource$, input$).pipe((0, operators_1.mergeMap)(async ([resource, input]) => {
            const output = await task(resource, input);
            //  Recycles a resource so its re-emitted from the `resource$` observable.
            recycleBin.next(resource);
            return output;
        }), (0, operators_1.tap)({ complete: () => recycleBin.complete() }));
    }
    /**
     * Dispose the pool
     */
    async dispose() {
        this.isDisposed = true;
        await Promise.all(this.createdResources.map((resource) => { var _a; return (_a = resource.dispose) === null || _a === void 0 ? void 0 : _a.call(resource); }));
    }
}
exports.Pool = Pool;
//# sourceMappingURL=pool.js.map