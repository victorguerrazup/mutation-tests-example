"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MutationTestExecutor = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const plugin_1 = require("@stryker-mutator/api/plugin");
const core_1 = require("@stryker-mutator/api/core");
const check_1 = require("@stryker-mutator/api/check");
const di_1 = require("../di");
/**
 * The factor by which hit count from dry run is multiplied to calculate the hit limit for a mutant.
 * This is intentionally a high value to prevent false positives.
 *
 * For example, a property testing library might execute a failing scenario multiple times to determine the smallest possible counterexample.
 * @see https://jsverify.github.io/#minimal-counterexample
 */
const HIT_LIMIT_FACTOR = 100;
class MutationTestExecutor {
    constructor(options, reporter, checkerPool, testRunnerPool, timeOverheadMS, matchedMutants, mutationTestReportHelper, sandbox, log, timer, concurrencyTokenProvider) {
        this.options = options;
        this.reporter = reporter;
        this.checkerPool = checkerPool;
        this.testRunnerPool = testRunnerPool;
        this.timeOverheadMS = timeOverheadMS;
        this.matchedMutants = matchedMutants;
        this.mutationTestReportHelper = mutationTestReportHelper;
        this.sandbox = sandbox;
        this.log = log;
        this.timer = timer;
        this.concurrencyTokenProvider = concurrencyTokenProvider;
    }
    async execute() {
        const { ignoredResult$, notIgnoredMutant$ } = this.executeIgnore((0, rxjs_1.from)(this.matchedMutants));
        const { passedMutant$, checkResult$ } = this.executeCheck((0, rxjs_1.from)(notIgnoredMutant$));
        const { coveredMutant$, noCoverageResult$ } = this.executeNoCoverage(passedMutant$);
        const testRunnerResult$ = this.executeRunInTestRunner(coveredMutant$);
        const results = await (0, rxjs_1.lastValueFrom)((0, rxjs_1.merge)(testRunnerResult$, checkResult$, noCoverageResult$, ignoredResult$).pipe((0, operators_1.toArray)()));
        this.mutationTestReportHelper.reportAll(results);
        await this.reporter.wrapUp();
        this.logDone();
        return results;
    }
    executeIgnore(input$) {
        const [ignoredMutant$, notIgnoredMutant$] = (0, rxjs_1.partition)(input$.pipe((0, operators_1.shareReplay)()), (mutant) => mutant.status === core_1.MutantStatus.Ignored);
        const ignoredResult$ = ignoredMutant$.pipe((0, operators_1.map)((mutant) => this.mutationTestReportHelper.reportMutantStatus(mutant, core_1.MutantStatus.Ignored)));
        return { ignoredResult$, notIgnoredMutant$ };
    }
    executeNoCoverage(input$) {
        const [noCoverageMatchedMutant$, coveredMutant$] = (0, rxjs_1.partition)(input$.pipe((0, operators_1.shareReplay)()), (mutant) => { var _a, _b; return !mutant.static && ((_b = (_a = mutant.coveredBy) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) === 0; });
        const noCoverageResult$ = noCoverageMatchedMutant$.pipe((0, operators_1.map)((mutant) => this.mutationTestReportHelper.reportMutantStatus(mutant, core_1.MutantStatus.NoCoverage)));
        return { noCoverageResult$, coveredMutant$ };
    }
    executeCheck(input$) {
        const checkTask$ = this.checkerPool
            .schedule(input$, async (checker, mutant) => {
            const checkResult = await checker.check(mutant);
            return {
                checkResult,
                mutant,
            };
        })
            .pipe(
        // Dispose when all checks are completed.
        // This will allow resources to be freed up and more test runners to be spined up.
        (0, operators_1.tap)({
            complete: () => {
                this.checkerPool.dispose();
                this.concurrencyTokenProvider.freeCheckers();
            },
        }), (0, operators_1.shareReplay)());
        const [passedCheckResult$, failedCheckResult$] = (0, rxjs_1.partition)(checkTask$, ({ checkResult }) => checkResult.status === check_1.CheckStatus.Passed);
        const checkResult$ = failedCheckResult$.pipe((0, operators_1.map)((failedMutant) => this.mutationTestReportHelper.reportCheckFailed(failedMutant.mutant, failedMutant.checkResult)));
        const passedMutant$ = passedCheckResult$.pipe((0, operators_1.map)(({ mutant }) => mutant));
        return { checkResult$, passedMutant$ };
    }
    executeRunInTestRunner(input$) {
        return this.testRunnerPool.schedule(input$, async (testRunner, mutant) => {
            const mutantRunOptions = this.createMutantRunOptions(mutant);
            const result = await testRunner.mutantRun(mutantRunOptions);
            return this.mutationTestReportHelper.reportMutantRunResult(mutant, result);
        });
    }
    createMutantRunOptions(activeMutant) {
        const timeout = this.options.timeoutFactor * activeMutant.estimatedNetTime + this.options.timeoutMS + this.timeOverheadMS;
        const hitLimit = activeMutant.hitCount === undefined ? undefined : activeMutant.hitCount * HIT_LIMIT_FACTOR;
        return {
            activeMutant,
            timeout,
            testFilter: activeMutant.coveredBy,
            sandboxFileName: this.sandbox.sandboxFileFor(activeMutant.fileName),
            hitLimit,
            disableBail: this.options.disableBail,
        };
    }
    logDone() {
        this.log.info('Done in %s.', this.timer.humanReadableElapsed());
    }
}
exports.MutationTestExecutor = MutationTestExecutor;
MutationTestExecutor.inject = (0, plugin_1.tokens)(plugin_1.commonTokens.options, di_1.coreTokens.reporter, di_1.coreTokens.checkerPool, di_1.coreTokens.testRunnerPool, di_1.coreTokens.timeOverheadMS, di_1.coreTokens.mutantsWithTestCoverage, di_1.coreTokens.mutationTestReportHelper, di_1.coreTokens.sandbox, plugin_1.commonTokens.logger, di_1.coreTokens.timer, di_1.coreTokens.concurrencyTokenProvider);
//# sourceMappingURL=4-mutation-test-executor.js.map