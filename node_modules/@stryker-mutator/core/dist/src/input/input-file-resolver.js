"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InputFileResolver = exports.MUTATION_RANGE_REGEX = exports.IGNORE_PATTERN_CHARACTER = void 0;
const tslib_1 = require("tslib");
const path_1 = (0, tslib_1.__importDefault)(require("path"));
const fs_1 = require("fs");
const util_1 = require("util");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const core_1 = require("@stryker-mutator/api/core");
const plugin_1 = require("@stryker-mutator/api/plugin");
const util_2 = require("@stryker-mutator/util");
const minimatch_1 = require("minimatch");
const di_1 = require("../di");
const file_utils_1 = require("../utils/file-utils");
const options_validator_1 = require("../config/options-validator");
const config_1 = require("../config");
const input_file_collection_1 = require("./input-file-collection");
function toReportSourceFile(file) {
    return {
        content: file.textContent,
        path: file.name,
    };
}
const ALWAYS_IGNORE = Object.freeze(['node_modules', '.git', '/reports', '*.tsbuildinfo', '/stryker.log']);
exports.IGNORE_PATTERN_CHARACTER = '!';
exports.MUTATION_RANGE_REGEX = /(.*?):((\d+)(?::(\d+))?-(\d+)(?::(\d+))?)$/;
class InputFileResolver {
    constructor(log, { mutate, tempDirName, ignorePatterns }, reporter) {
        this.log = log;
        this.reporter = reporter;
        this.mutatePatterns = mutate;
        this.ignoreRules = [...ALWAYS_IGNORE, tempDirName, ...ignorePatterns];
    }
    async resolve() {
        const inputFileNames = await this.resolveInputFiles();
        const mutateFiles = this.resolveMutateFiles(inputFileNames);
        const mutationRange = this.resolveMutationRange();
        const files = await this.readFiles(inputFileNames);
        const inputFileCollection = new input_file_collection_1.InputFileCollection(files, mutateFiles, mutationRange);
        this.reportAllSourceFilesRead(files);
        inputFileCollection.logFiles(this.log, this.ignoreRules);
        return inputFileCollection;
    }
    resolveMutateFiles(inputFileNames) {
        return this.filterPatterns(inputFileNames, this.mutatePatterns, !(0, util_1.isDeepStrictEqual)(this.mutatePatterns, (0, options_validator_1.defaultOptions)().mutate));
    }
    resolveMutationRange() {
        return this.mutatePatterns
            .map((fileToMutate) => exports.MUTATION_RANGE_REGEX.exec(fileToMutate))
            .filter(util_2.notEmpty)
            .map(([_, fileName, _mutationRange, startLine, startColumn = '0', endLine, endColumn = Number.MAX_SAFE_INTEGER.toString()]) => {
            return {
                fileName: path_1.default.resolve(fileName),
                start: { line: parseInt(startLine) - 1, column: parseInt(startColumn) },
                end: { line: parseInt(endLine) - 1, column: parseInt(endColumn) },
            };
        });
    }
    /**
     * Takes a list of globbing patterns and expands them into files.
     * If a patterns starts with a `!`, it negates the pattern.
     * @param fileNames the file names to filter
     * @param patterns The patterns to expand into files
     * @param logAboutUselessPatterns Weather or not to log about useless patterns
     */
    filterPatterns(fileNames, patterns, logAboutUselessPatterns) {
        const fileSet = new Set();
        for (const pattern of patterns) {
            if (pattern.startsWith(exports.IGNORE_PATTERN_CHARACTER)) {
                const files = this.filterPattern(fileSet, pattern.substr(1));
                if (logAboutUselessPatterns && files.length === 0) {
                    this.log.warn(`Glob pattern "${pattern}" did not exclude any files.`);
                }
                files.forEach((fileName) => fileSet.delete(fileName));
            }
            else {
                const files = this.filterPattern(fileNames, pattern);
                if (logAboutUselessPatterns && files.length === 0) {
                    this.log.warn(`Glob pattern "${pattern}" did not result in any files.`);
                }
                files.forEach((fileName) => fileSet.add(fileName));
            }
        }
        return Array.from(fileSet);
    }
    filterPattern(fileNames, pattern) {
        if (exports.MUTATION_RANGE_REGEX.exec(pattern)) {
            pattern = pattern.replace(exports.MUTATION_RANGE_REGEX, '$1');
        }
        const matcher = new config_1.FileMatcher(pattern);
        const filteredFileNames = [...fileNames].filter((fileName) => matcher.matches(fileName));
        return filteredFileNames;
    }
    async resolveInputFiles() {
        const ignoreRules = this.ignoreRules.map((pattern) => new minimatch_1.Minimatch(pattern, { dot: true, flipNegate: true, nocase: true }));
        /**
         * Rewrite of: https://github.com/npm/ignore-walk/blob/0e4f87adccb3e16f526d2e960ed04bdc77fd6cca/index.js#L213-L215
         */
        const matchesDirectoryPartially = (entryPath, rule) => {
            // @ts-expect-error Missing overload in type definitions. See https://github.com/isaacs/minimatch/issues/134
            return rule.match(`/${entryPath}`, true) || rule.match(entryPath, true);
        };
        // Inspired by https://github.com/npm/ignore-walk/blob/0e4f87adccb3e16f526d2e960ed04bdc77fd6cca/index.js#L124
        const matchesDirectory = (entryName, entryPath, rule) => {
            return (matchesFile(entryName, entryPath, rule) ||
                rule.match(`/${entryPath}/`) ||
                rule.match(`${entryPath}/`) ||
                (rule.negate && matchesDirectoryPartially(entryPath, rule)));
        };
        // Inspired by https://github.com/npm/ignore-walk/blob/0e4f87adccb3e16f526d2e960ed04bdc77fd6cca/index.js#L123
        const matchesFile = (entryName, entryPath, rule) => {
            return rule.match(entryName) || rule.match(entryPath) || rule.match(`/${entryPath}`);
        };
        const crawlDir = async (dir, rootDir = dir) => {
            const dirEntries = await fs_1.promises.readdir(dir, { withFileTypes: true });
            const relativeName = path_1.default.relative(rootDir, dir);
            const files = await Promise.all(dirEntries
                .filter((dirEntry) => {
                let included = true;
                const entryPath = `${relativeName.length ? `${relativeName}/` : ''}${dirEntry.name}`;
                ignoreRules.forEach((rule) => {
                    if (rule.negate !== included) {
                        const match = dirEntry.isDirectory() ? matchesDirectory(dirEntry.name, entryPath, rule) : matchesFile(dirEntry.name, entryPath, rule);
                        if (match) {
                            included = rule.negate;
                        }
                    }
                });
                return included;
            })
                .map(async (dirent) => {
                if (dirent.isDirectory()) {
                    return crawlDir(path_1.default.resolve(rootDir, relativeName, dirent.name), rootDir);
                }
                else {
                    return path_1.default.resolve(rootDir, relativeName, dirent.name);
                }
            }));
            return files.flat();
        };
        const files = await crawlDir(process.cwd());
        return files;
    }
    reportAllSourceFilesRead(allFiles) {
        this.reporter.onAllSourceFilesRead(allFiles.map(toReportSourceFile));
    }
    reportSourceFilesRead(textFile) {
        this.reporter.onSourceFileRead(toReportSourceFile(textFile));
    }
    async readFiles(fileNames) {
        const files$ = (0, rxjs_1.from)(fileNames).pipe((0, operators_1.mergeMap)((fileName) => {
            return this.readFile(fileName);
        }, file_utils_1.MAX_CONCURRENT_FILE_IO), (0, operators_1.filter)(util_2.notEmpty), (0, operators_1.toArray)(), 
        // Filter the files here, so we force a deterministic instrumentation process
        (0, operators_1.map)((files) => files.sort((a, b) => (a.name < b.name ? -1 : a.name > b.name ? 1 : 0))));
        return (0, rxjs_1.lastValueFrom)(files$);
    }
    async readFile(fileName) {
        try {
            const content = await fs_1.promises.readFile(fileName);
            const file = new core_1.File(fileName, content);
            this.reportSourceFilesRead(file);
            return file;
        }
        catch (error) {
            if ((0, util_2.isErrnoException)(error) && (error.code === 'ENOENT' || error.code === 'EISDIR')) {
                return null; // file is deleted or a directory.
            }
            else {
                // Rethrow
                throw error;
            }
        }
    }
}
exports.InputFileResolver = InputFileResolver;
InputFileResolver.inject = (0, plugin_1.tokens)(plugin_1.commonTokens.logger, plugin_1.commonTokens.options, di_1.coreTokens.reporter);
//# sourceMappingURL=input-file-resolver.js.map